From d264c66f9950cb2331c22c21172a07520fb38c68 Mon Sep 17 00:00:00 2001
From: pipetto-crypto <pipetto-crypto@gmail.com>
Date: Wed, 7 Aug 2024 18:38:40 +0200
Subject: [PATCH] revert wsi_common_x11 to an older version Winlator likes

---
 src/vulkan/wsi/wsi_common_x11.c | 2201 ++++++++++++++-----------------
 1 file changed, 959 insertions(+), 1242 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 9bf048c2a164d..9ecee09ee712c 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -22,14 +22,7 @@
  */
 
 #include <X11/Xlib-xcb.h>
-#include <X11/xshmfence.h>
-#define XK_MISCELLANY
-#define XK_LATIN1
-#include <X11/keysymdef.h>
 #include <xcb/xcb.h>
-#ifdef XCB_KEYSYMS_AVAILABLE
-#include <xcb/xcb_keysyms.h>
-#endif
 #include <xcb/dri3.h>
 #include <xcb/present.h>
 #include <xcb/shm.h>
@@ -42,11 +35,10 @@
 #include <errno.h>
 #include <string.h>
 #include <fcntl.h>
+#include <poll.h>
+#include <xf86drm.h>
 #include "drm-uapi/drm_fourcc.h"
-#include "util/libdrm.h"
-#include "util/cnd_monotonic.h"
 #include "util/hash_table.h"
-#include "util/mesa-blake3.h"
 #include "util/os_file.h"
 #include "util/os_time.h"
 #include "util/u_debug.h"
@@ -57,7 +49,6 @@
 #include "vk_format.h"
 #include "vk_instance.h"
 #include "vk_physical_device.h"
-#include "vk_device.h"
 #include "vk_util.h"
 #include "vk_enum_to_str.h"
 #include "wsi_common_entrypoints.h"
@@ -69,41 +60,21 @@
 #include <sys/shm.h>
 #endif
 
-#ifndef XCB_PRESENT_OPTION_ASYNC_MAY_TEAR
-#define XCB_PRESENT_OPTION_ASYNC_MAY_TEAR 16
-#endif
-#ifndef XCB_PRESENT_CAPABILITY_ASYNC_MAY_TEAR
-#define XCB_PRESENT_CAPABILITY_ASYNC_MAY_TEAR 8
-#endif
-
-#define MAX_DAMAGE_RECTS 64
-
 struct wsi_x11_connection {
    bool has_dri3;
    bool has_dri3_modifiers;
-   bool has_dri3_explicit_sync;
    bool has_present;
-   bool is_proprietary_x11;
-   bool is_xwayland;
    bool has_mit_shm;
-   bool has_xfixes;
 };
 
 struct wsi_x11 {
    struct wsi_interface base;
 
-   mtx_t mutex;
+   pthread_mutex_t                              mutex;
    /* Hash table of xcb_connection -> wsi_x11_connection mappings */
    struct hash_table *connections;
 };
 
-struct wsi_x11_vk_surface {
-   union {
-      VkIcdSurfaceXlib xlib;
-      VkIcdSurfaceXcb xcb;
-   };
-   bool has_alpha;
-};
 
 /**
  * Wrapper around xcb_dri3_open. Returns the opened fd or -1 on error.
@@ -149,7 +120,6 @@ static bool
 wsi_x11_check_dri3_compatible(const struct wsi_device *wsi_dev,
                               xcb_connection_t *conn)
 {
-   bool match;
    xcb_screen_iterator_t screen_iter =
       xcb_setup_roots_iterator(xcb_get_setup(conn));
    xcb_screen_t *screen = screen_iter.data;
@@ -160,90 +130,23 @@ wsi_x11_check_dri3_compatible(const struct wsi_device *wsi_dev,
    int dri3_fd = wsi_dri3_open(conn, screen->root, None);
    if (dri3_fd == -1)
       return true;
-   #ifdef HAVE_LIBDRM
-   match = wsi_device_matches_drm_fd(wsi_dev, dri3_fd);
-   #else
-   match = true;
-   #endif
-   
+
+   bool match = true;
 
    close(dri3_fd);
 
    return match;
 }
 
-static bool
-wsi_x11_detect_xwayland(xcb_connection_t *conn,
-                        xcb_query_extension_reply_t *randr_reply,
-                        xcb_query_extension_reply_t *xwl_reply)
-{
-   /* Newer Xwayland exposes an X11 extension we can check for */
-   if (xwl_reply && xwl_reply->present)
-      return true;
-
-   /* Older Xwayland uses the word "XWAYLAND" in the RandR output names */
-   if (!randr_reply || !randr_reply->present)
-      return false;
-
-   xcb_randr_query_version_cookie_t ver_cookie =
-      xcb_randr_query_version_unchecked(conn, 1, 3);
-   xcb_randr_query_version_reply_t *ver_reply =
-      xcb_randr_query_version_reply(conn, ver_cookie, NULL);
-   bool has_randr_v1_3 = ver_reply && (ver_reply->major_version > 1 ||
-                                       ver_reply->minor_version >= 3);
-   free(ver_reply);
-
-   if (!has_randr_v1_3)
-      return false;
-
-   const xcb_setup_t *setup = xcb_get_setup(conn);
-   xcb_screen_iterator_t iter = xcb_setup_roots_iterator(setup);
-
-   xcb_randr_get_screen_resources_current_cookie_t gsr_cookie =
-      xcb_randr_get_screen_resources_current_unchecked(conn, iter.data->root);
-   xcb_randr_get_screen_resources_current_reply_t *gsr_reply =
-      xcb_randr_get_screen_resources_current_reply(conn, gsr_cookie, NULL);
-
-   if (!gsr_reply || gsr_reply->num_outputs == 0) {
-      free(gsr_reply);
-      return false;
-   }
-
-   xcb_randr_output_t *randr_outputs =
-      xcb_randr_get_screen_resources_current_outputs(gsr_reply);
-   xcb_randr_get_output_info_cookie_t goi_cookie =
-      xcb_randr_get_output_info(conn, randr_outputs[0], gsr_reply->config_timestamp);
-   free(gsr_reply);
-
-   xcb_randr_get_output_info_reply_t *goi_reply =
-      xcb_randr_get_output_info_reply(conn, goi_cookie, NULL);
-   if (!goi_reply) {
-      return false;
-   }
-
-   char *output_name = (char*)xcb_randr_get_output_info_name(goi_reply);
-   bool is_xwayland = output_name && strncmp(output_name, "XWAYLAND", 8) == 0;
-   free(goi_reply);
-
-   return is_xwayland;
-}
-
 static struct wsi_x11_connection *
 wsi_x11_connection_create(struct wsi_device *wsi_dev,
                           xcb_connection_t *conn)
 {
-   xcb_query_extension_cookie_t dri3_cookie, pres_cookie, randr_cookie,
-                                amd_cookie, nv_cookie, shm_cookie, sync_cookie,
-                                xfixes_cookie, xwl_cookie;
-   xcb_query_extension_reply_t *dri3_reply, *pres_reply, *randr_reply,
-                               *amd_reply, *nv_reply, *shm_reply = NULL,
-                               *xfixes_reply, *xwl_reply;
-   bool wants_shm = wsi_dev->sw && !(WSI_DEBUG & WSI_DEBUG_NOSHM) &&
-                    wsi_dev->has_import_memory_host;
+   xcb_query_extension_cookie_t dri3_cookie, pres_cookie, shm_cookie, sync_cookie;
+   xcb_query_extension_reply_t *dri3_reply, *pres_reply, *shm_reply = NULL;
+   bool wants_shm = wsi_dev->sw && !(WSI_DEBUG & WSI_DEBUG_NOSHM);
    bool has_dri3_v1_2 = false;
    bool has_present_v1_2 = false;
-   bool has_dri3_v1_4 = false;
-   bool has_present_v1_4 = false;
 
    struct wsi_x11_connection *wsi_conn =
       vk_alloc(&wsi_dev->instance_alloc, sizeof(*wsi_conn), 8,
@@ -254,45 +157,14 @@ wsi_x11_connection_create(struct wsi_device *wsi_dev,
    sync_cookie = xcb_query_extension(conn, 4, "SYNC");
    dri3_cookie = xcb_query_extension(conn, 4, "DRI3");
    pres_cookie = xcb_query_extension(conn, 7, "Present");
-   randr_cookie = xcb_query_extension(conn, 5, "RANDR");
-   xfixes_cookie = xcb_query_extension(conn, 6, "XFIXES");
-   xwl_cookie = xcb_query_extension(conn, 8, "XWAYLAND");
-
-   if (wants_shm)
-      shm_cookie = xcb_query_extension(conn, 7, "MIT-SHM");
-
-   /* We try to be nice to users and emit a warning if they try to use a
-    * Vulkan application on a system without DRI3 enabled.  However, this ends
-    * up spewing the warning when a user has, for example, both Intel
-    * integrated graphics and a discrete card with proprietary drivers and are
-    * running on the discrete card with the proprietary DDX.  In this case, we
-    * really don't want to print the warning because it just confuses users.
-    * As a heuristic to detect this case, we check for a couple of proprietary
-    * X11 extensions.
-    */
-   amd_cookie = xcb_query_extension(conn, 11, "ATIFGLRXDRI");
-   nv_cookie = xcb_query_extension(conn, 10, "NV-CONTROL");
 
    xcb_discard_reply(conn, sync_cookie.sequence);
    dri3_reply = xcb_query_extension_reply(conn, dri3_cookie, NULL);
    pres_reply = xcb_query_extension_reply(conn, pres_cookie, NULL);
-   randr_reply = xcb_query_extension_reply(conn, randr_cookie, NULL);
-   amd_reply = xcb_query_extension_reply(conn, amd_cookie, NULL);
-   nv_reply = xcb_query_extension_reply(conn, nv_cookie, NULL);
-   xfixes_reply = xcb_query_extension_reply(conn, xfixes_cookie, NULL);
-   xwl_reply = xcb_query_extension_reply(conn, xwl_cookie, NULL);
-   if (wants_shm)
-      shm_reply = xcb_query_extension_reply(conn, shm_cookie, NULL);
-   if (!dri3_reply || !pres_reply || !xfixes_reply) {
+
+   if (!dri3_reply || !pres_reply) {
       free(dri3_reply);
       free(pres_reply);
-      free(xfixes_reply);
-      free(xwl_reply);
-      free(randr_reply);
-      free(amd_reply);
-      free(nv_reply);
-      if (wants_shm)
-         free(shm_reply);
       vk_free(&wsi_dev->instance_alloc, wsi_conn);
       return NULL;
    }
@@ -303,12 +175,10 @@ wsi_x11_connection_create(struct wsi_device *wsi_dev,
       xcb_dri3_query_version_cookie_t ver_cookie;
       xcb_dri3_query_version_reply_t *ver_reply;
 
-      ver_cookie = xcb_dri3_query_version(conn, 1, 4);
+      ver_cookie = xcb_dri3_query_version(conn, 1, 2);
       ver_reply = xcb_dri3_query_version_reply(conn, ver_cookie, NULL);
       has_dri3_v1_2 = ver_reply != NULL &&
          (ver_reply->major_version > 1 || ver_reply->minor_version >= 2);
-      has_dri3_v1_4 = ver_reply != NULL &&
-         (ver_reply->major_version > 1 || ver_reply->minor_version >= 4);
       free(ver_reply);
    }
 #endif
@@ -319,73 +189,27 @@ wsi_x11_connection_create(struct wsi_device *wsi_dev,
       xcb_present_query_version_cookie_t ver_cookie;
       xcb_present_query_version_reply_t *ver_reply;
 
-      ver_cookie = xcb_present_query_version(conn, 1, 4);
+      ver_cookie = xcb_present_query_version(conn, 1, 2);
       ver_reply = xcb_present_query_version_reply(conn, ver_cookie, NULL);
       has_present_v1_2 =
         (ver_reply->major_version > 1 || ver_reply->minor_version >= 2);
-      has_present_v1_4 =
-        (ver_reply->major_version > 1 || ver_reply->minor_version >= 4);
       free(ver_reply);
    }
 #endif
 
-   wsi_conn->has_xfixes = xfixes_reply->present != 0;
-   if (wsi_conn->has_xfixes) {
-      xcb_xfixes_query_version_cookie_t ver_cookie;
-      xcb_xfixes_query_version_reply_t *ver_reply;
-
-      ver_cookie = xcb_xfixes_query_version(conn, 6, 0);
-      ver_reply = xcb_xfixes_query_version_reply(conn, ver_cookie, NULL);
-      wsi_conn->has_xfixes = (ver_reply->major_version >= 2);
-      free(ver_reply);
-   }
-
-   wsi_conn->is_xwayland = wsi_x11_detect_xwayland(conn, randr_reply,
-                                                   xwl_reply);
+   free(dri3_reply);
+   free(pres_reply);
 
    wsi_conn->has_dri3_modifiers = has_dri3_v1_2 && has_present_v1_2;
-   wsi_conn->has_dri3_explicit_sync = has_dri3_v1_4 && has_present_v1_4;
-   wsi_conn->is_proprietary_x11 = false;
-   if (amd_reply && amd_reply->present)
-      wsi_conn->is_proprietary_x11 = true;
-   if (nv_reply && nv_reply->present)
-      wsi_conn->is_proprietary_x11 = true;
 
    wsi_conn->has_mit_shm = false;
-   if (wsi_conn->has_dri3 && wsi_conn->has_present && wants_shm) {
-      bool has_mit_shm = shm_reply->present != 0;
-
-      xcb_shm_query_version_cookie_t ver_cookie;
-      xcb_shm_query_version_reply_t *ver_reply;
-
-      ver_cookie = xcb_shm_query_version(conn);
-      ver_reply = xcb_shm_query_version_reply(conn, ver_cookie, NULL);
-
-      has_mit_shm = ver_reply->shared_pixmaps;
-      free(ver_reply);
-      xcb_void_cookie_t cookie;
-      xcb_generic_error_t *error;
-
-      if (has_mit_shm) {
-         cookie = xcb_shm_detach_checked(conn, 0);
-         if ((error = xcb_request_check(conn, cookie))) {
-            if (error->error_code != BadRequest)
-               wsi_conn->has_mit_shm = true;
-            free(error);
-         }
-      }
+   if (wants_shm) {
+      xcb_query_extension_cookie_t cookie = xcb_query_extension(conn, 7, "MIT-SHM");
+	  xcb_query_extension_reply_t *shm_reply = xcb_query_extension_reply(conn, cookie, NULL);
+	  wsi_conn->has_mit_shm = shm_reply->present != 0;
+	  free(shm_reply);
    }
 
-   free(dri3_reply);
-   free(pres_reply);
-   free(randr_reply);
-   free(xwl_reply);
-   free(amd_reply);
-   free(nv_reply);
-   free(xfixes_reply);
-   if (wants_shm)
-      free(shm_reply);
-
    return wsi_conn;
 }
 
@@ -401,10 +225,7 @@ wsi_x11_check_for_dri3(struct wsi_x11_connection *wsi_conn)
 {
   if (wsi_conn->has_dri3)
     return true;
-  if (!wsi_conn->is_proprietary_x11) {
-    fprintf(stderr, "vulkan: No DRI3 support detected - required for presentation\n"
-                    "Note: you can probably enable DRI3 in your Xorg config\n");
-  }
+
   return false;
 }
 
@@ -423,21 +244,21 @@ wsi_x11_get_connection(struct wsi_device *wsi_dev,
    struct wsi_x11 *wsi =
       (struct wsi_x11 *)wsi_dev->wsi[VK_ICD_WSI_PLATFORM_XCB];
 
-   mtx_lock(&wsi->mutex);
+   pthread_mutex_lock(&wsi->mutex);
 
    struct hash_entry *entry = _mesa_hash_table_search(wsi->connections, conn);
    if (!entry) {
       /* We're about to make a bunch of blocking calls.  Let's drop the
        * mutex for now so we don't block up too badly.
        */
-      mtx_unlock(&wsi->mutex);
+      pthread_mutex_unlock(&wsi->mutex);
 
       struct wsi_x11_connection *wsi_conn =
          wsi_x11_connection_create(wsi_dev, conn);
       if (!wsi_conn)
          return NULL;
 
-      mtx_lock(&wsi->mutex);
+      pthread_mutex_lock(&wsi->mutex);
 
       entry = _mesa_hash_table_search(wsi->connections, conn);
       if (entry) {
@@ -448,7 +269,7 @@ wsi_x11_get_connection(struct wsi_device *wsi_dev,
       }
    }
 
-   mtx_unlock(&wsi->mutex);
+   pthread_mutex_unlock(&wsi->mutex);
 
    return entry->data;
 }
@@ -588,9 +409,6 @@ wsi_GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice,
 {
    VK_FROM_HANDLE(vk_physical_device, pdevice, physicalDevice);
    struct wsi_device *wsi_device = pdevice->wsi_device;
-   if (!(wsi_device->queue_supports_blit & BITFIELD64_BIT(queueFamilyIndex)))
-      return false;
-
    struct wsi_x11_connection *wsi_conn =
       wsi_x11_get_connection(wsi_device, connection);
 
@@ -669,7 +487,7 @@ x11_surface_get_support(VkIcdSurfaceBase *icd_surface,
 }
 
 static uint32_t
-x11_get_min_image_count(const struct wsi_device *wsi_device, bool is_xwayland)
+x11_get_min_image_count(const struct wsi_device *wsi_device)
 {
    if (wsi_device->x11.override_minImageCount)
       return wsi_device->x11.override_minImageCount;
@@ -692,10 +510,8 @@ x11_get_min_image_count(const struct wsi_device *wsi_device, bool is_xwayland)
     * This is a tradeoff as it uses more memory than needed for non-fullscreen
     * and non-performance intensive applications.
     *
-    * For Xwayland Venus reports four images as described in
-    *   wsi_wl_surface_get_capabilities
     */
-   return is_xwayland && wsi_device->x11.extra_xwayland_image ? 4 : 3;
+   return 3;
 }
 
 static unsigned
@@ -711,19 +527,26 @@ x11_surface_get_capabilities(VkIcdSurfaceBase *icd_surface,
 {
    xcb_connection_t *conn = x11_surface_get_connection(icd_surface);
    xcb_window_t window = x11_surface_get_window(icd_surface);
-   struct wsi_x11_vk_surface *surface = (struct wsi_x11_vk_surface*)icd_surface;
    struct wsi_x11_connection *wsi_conn =
       wsi_x11_get_connection(wsi_device, conn);
    xcb_get_geometry_cookie_t geom_cookie;
    xcb_generic_error_t *err;
    xcb_get_geometry_reply_t *geom;
+   unsigned visual_depth;
 
    geom_cookie = xcb_get_geometry(conn, window);
 
-   geom = xcb_get_geometry_reply(conn, geom_cookie, &err);
-   if (!geom)
+   /* This does a round-trip.  This is why we do get_geometry first and
+    * wait to read the reply until after we have a visual.
+    */
+   xcb_visualtype_t *visual =
+      get_visualtype_for_window(conn, window, &visual_depth, NULL);
+
+   if (!visual)
       return VK_ERROR_SURFACE_LOST_KHR;
-   {
+
+   geom = xcb_get_geometry_reply(conn, geom_cookie, &err);
+   if (geom) {
       VkExtent2D extent = { geom->width, geom->height };
       caps->currentExtent = extent;
       caps->minImageExtent = extent;
@@ -731,8 +554,10 @@ x11_surface_get_capabilities(VkIcdSurfaceBase *icd_surface,
    }
    free(err);
    free(geom);
+   if (!geom)
+       return VK_ERROR_SURFACE_LOST_KHR;
 
-   if (surface->has_alpha) {
+   if (visual_has_alpha(visual, visual_depth)) {
       caps->supportedCompositeAlpha = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR |
                                       VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR;
    } else {
@@ -740,10 +565,14 @@ x11_surface_get_capabilities(VkIcdSurfaceBase *icd_surface,
                                       VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    }
 
-   if (present_mode) {
-      caps->minImageCount = x11_get_min_image_count_for_present_mode(wsi_device, wsi_conn, present_mode->presentMode);
+   if (wsi_device->sw) {
+      caps->minImageCount = 1;
    } else {
-      caps->minImageCount = x11_get_min_image_count(wsi_device, wsi_conn->is_xwayland);
+      if (present_mode) {
+         caps->minImageCount = x11_get_min_image_count_for_present_mode(wsi_device, wsi_conn, present_mode->presentMode);
+      } else {
+         caps->minImageCount = x11_get_min_image_count(wsi_device);
+      }
    }
 
    /* There is no real maximum */
@@ -752,11 +581,13 @@ x11_surface_get_capabilities(VkIcdSurfaceBase *icd_surface,
    caps->supportedTransforms = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
    caps->currentTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
    caps->maxImageArrayLayers = 1;
-   caps->supportedUsageFlags = wsi_caps_get_image_usage();
-
-   VK_FROM_HANDLE(vk_physical_device, pdevice, wsi_device->pdevice);
-   if (pdevice->supported_extensions.EXT_attachment_feedback_loop_layout)
-      caps->supportedUsageFlags |= VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT;
+   caps->supportedUsageFlags =
+      VK_IMAGE_USAGE_TRANSFER_SRC_BIT |
+      VK_IMAGE_USAGE_SAMPLED_BIT |
+      VK_IMAGE_USAGE_TRANSFER_DST_BIT |
+      VK_IMAGE_USAGE_STORAGE_BIT |
+      VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |
+      VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
 
    return VK_SUCCESS;
 }
@@ -798,30 +629,17 @@ x11_surface_get_capabilities2(VkIcdSurfaceBase *icd_surface,
       }
 
       case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {
-         /* All present modes are compatible with each other. */
+         /* To be able to toggle between FIFO and non-FIFO, we would need a rewrite to always use FIFO thread
+          * mechanism. For now, only return the input, making this effectively unsupported. */
          VkSurfacePresentModeCompatibilityEXT *compat = (void *)ext;
          if (compat->pPresentModes) {
-            assert(present_mode);
-            VK_OUTARRAY_MAKE_TYPED(VkPresentModeKHR, modes, compat->pPresentModes, &compat->presentModeCount);
-            /* Must always return queried present mode even when truncating. */
-            vk_outarray_append_typed(VkPresentModeKHR, &modes, mode) {
-               *mode = present_mode->presentMode;
-            }
-
-            for (uint32_t i = 0; i < ARRAY_SIZE(present_modes); i++) {
-               if (present_modes[i] != present_mode->presentMode) {
-                  vk_outarray_append_typed(VkPresentModeKHR, &modes, mode) {
-                     *mode = present_modes[i];
-                  }
-               }
+            if (compat->presentModeCount) {
+               assert(present_mode);
+               compat->pPresentModes[0] = present_mode->presentMode;
+               compat->presentModeCount = 1;
             }
          } else {
-            if (!present_mode)
-               wsi_common_vk_warn_once("Use of VkSurfacePresentModeCompatibilityEXT "
-                                       "without a VkSurfacePresentModeEXT set. This is an "
-                                       "application bug.\n");
-
-            compat->presentModeCount = ARRAY_SIZE(present_modes);
+            compat->presentModeCount = 1;
          }
          break;
       }
@@ -995,28 +813,20 @@ wsi_CreateXcbSurfaceKHR(VkInstance _instance,
                         VkSurfaceKHR *pSurface)
 {
    VK_FROM_HANDLE(vk_instance, instance, _instance);
-   struct wsi_x11_vk_surface *surface;
+   VkIcdSurfaceXcb *surface;
 
    assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR);
 
-   unsigned visual_depth;
-   xcb_visualtype_t *visual =
-      get_visualtype_for_window(pCreateInfo->connection, pCreateInfo->window, &visual_depth, NULL);
-   if (!visual)
-      return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-   surface = vk_alloc2(&instance->alloc, pAllocator, sizeof(struct wsi_x11_vk_surface), 8,
+   surface = vk_alloc2(&instance->alloc, pAllocator, sizeof *surface, 8,
                        VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
    if (surface == NULL)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-   surface->xcb.base.platform = VK_ICD_WSI_PLATFORM_XCB;
-   surface->xcb.connection = pCreateInfo->connection;
-   surface->xcb.window = pCreateInfo->window;
-
-   surface->has_alpha = visual_has_alpha(visual, visual_depth);
+   surface->base.platform = VK_ICD_WSI_PLATFORM_XCB;
+   surface->connection = pCreateInfo->connection;
+   surface->window = pCreateInfo->window;
 
-   *pSurface = VkIcdSurfaceBase_to_handle(&surface->xcb.base);
+   *pSurface = VkIcdSurfaceBase_to_handle(&surface->base);
    return VK_SUCCESS;
 }
 
@@ -1027,63 +837,35 @@ wsi_CreateXlibSurfaceKHR(VkInstance _instance,
                          VkSurfaceKHR *pSurface)
 {
    VK_FROM_HANDLE(vk_instance, instance, _instance);
-   struct wsi_x11_vk_surface *surface;
+   VkIcdSurfaceXlib *surface;
 
    assert(pCreateInfo->sType == VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR);
 
-   unsigned visual_depth;
-   xcb_visualtype_t *visual =
-      get_visualtype_for_window(XGetXCBConnection(pCreateInfo->dpy), pCreateInfo->window, &visual_depth, NULL);
-   if (!visual)
-      return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-   surface = vk_alloc2(&instance->alloc, pAllocator, sizeof(struct wsi_x11_vk_surface), 8,
+   surface = vk_alloc2(&instance->alloc, pAllocator, sizeof *surface, 8,
                        VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
    if (surface == NULL)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-   surface->xlib.base.platform = VK_ICD_WSI_PLATFORM_XLIB;
-   surface->xlib.dpy = pCreateInfo->dpy;
-   surface->xlib.window = pCreateInfo->window;
-
-   surface->has_alpha = visual_has_alpha(visual, visual_depth);
+   surface->base.platform = VK_ICD_WSI_PLATFORM_XLIB;
+   surface->dpy = pCreateInfo->dpy;
+   surface->window = pCreateInfo->window;
 
-   *pSurface = VkIcdSurfaceBase_to_handle(&surface->xlib.base);
+   *pSurface = VkIcdSurfaceBase_to_handle(&surface->base);
    return VK_SUCCESS;
 }
 
-struct x11_image_pending_completion {
-   uint32_t serial;
-   uint64_t signal_present_id;
-};
-
 struct x11_image {
    struct wsi_image                          base;
    xcb_pixmap_t                              pixmap;
-   xcb_xfixes_region_t                       update_region; /* long lived XID */
-   xcb_xfixes_region_t                       update_area;   /* the above or None */
-   struct xshmfence *                        shm_fence;
+   atomic_bool                               busy;
+   bool                                      present_queued;
    uint32_t                                  sync_fence;
+   uint32_t                                  serial;
    xcb_shm_seg_t                             shmseg;
    int                                       shmid;
    uint8_t *                                 shmaddr;
    uint64_t                                  present_id;
-   VkPresentModeKHR                          present_mode;
-   xcb_rectangle_t                           rects[MAX_DAMAGE_RECTS];
-   int                                       rectangle_count;
-
-   /* In IMMEDIATE and MAILBOX modes, we can have multiple pending presentations per image.
-    * We need to keep track of them when considering present ID. */
-
-   /* This is arbitrarily chosen. With IMMEDIATE on a 3 deep swapchain,
-    * we allow up to 48 outstanding presentations per vblank, which is more than enough
-    * for any reasonable application. */
-#define X11_SWAPCHAIN_MAX_PENDING_COMPLETIONS 16
-   uint32_t                                  present_queued_count;
-   struct x11_image_pending_completion       pending_completions[X11_SWAPCHAIN_MAX_PENDING_COMPLETIONS];
-#ifdef HAVE_DRI3_EXPLICIT_SYNC
-   uint32_t                                  dri3_syncobj[WSI_ES_COUNT];
-#endif
+   uint64_t                                  signal_present_id;
 };
 
 struct x11_swapchain {
@@ -1091,7 +873,6 @@ struct x11_swapchain {
 
    bool                                         has_dri3_modifiers;
    bool                                         has_mit_shm;
-   bool                                         has_async_may_tear;
 
    xcb_connection_t *                           conn;
    xcb_window_t                                 window;
@@ -1099,80 +880,103 @@ struct x11_swapchain {
    uint32_t                                     depth;
    VkExtent2D                                   extent;
 
-   blake3_hash                                  dri3_modifier_hash;
-
    xcb_present_event_t                          event_id;
    xcb_special_event_t *                        special_event;
    uint64_t                                     send_sbc;
    uint64_t                                     last_present_msc;
    uint32_t                                     stamp;
-   uint32_t                                     sent_image_count;
+   atomic_int                                   sent_image_count;
 
-   atomic_int                                   status;
+   bool                                         has_present_queue;
+   bool                                         has_acquire_queue;
+   VkResult                                     status;
    bool                                         copy_is_suboptimal;
    struct wsi_queue                             present_queue;
    struct wsi_queue                             acquire_queue;
-   thrd_t                                       queue_manager;
-   thrd_t                                       event_manager;
-
-   /* Used for communicating between event_manager and queue_manager.
-    * Lock is also taken when reading and writing status.
-    * When reading status in application threads,
-    * x11_swapchain_read_status_atomic can be used as a wrapper function. */
-   mtx_t                                        thread_state_lock;
-   struct u_cnd_monotonic                       thread_state_cond;
-
-   /* Lock and condition variable for present wait.
-    * Signalled by event thread and waited on by callers to PresentWaitKHR. */
-   mtx_t                                        present_progress_mutex;
-   struct u_cnd_monotonic                       present_progress_cond;
+   pthread_t                                    queue_manager;
+
+   /* Lock and condition variable that lets callers monitor forward progress in the swapchain.
+    * This includes:
+    * - Present ID completion updates (present_id).
+    * - Pending ID pending updates (present_id_pending).
+    * - Any errors happening while blocking on present progress updates (present_progress_error).
+    * - present_submitted_count.
+    */
+   pthread_mutex_t                              present_progress_mutex;
+   pthread_cond_t                               present_progress_cond;
+
+   /* Lock needs to be taken when waiting for and reading presentation events.
+    * Only relevant in non-FIFO modes where AcquireNextImage or WaitForPresentKHR may
+    * have to pump the XCB connection on its own. */
+   pthread_mutex_t                              present_poll_mutex;
+
+   /* For VK_KHR_present_wait. */
    uint64_t                                     present_id;
+   uint64_t                                     present_id_pending;
+
+   /* When blocking on present progress, this can be set and progress_cond is signalled to unblock waiters. */
    VkResult                                     present_progress_error;
 
+   /* For handling wait_ready scenario where two different threads can pump the connection. */
+
+   /* Updated by presentation thread. Incremented when a present is submitted to X.
+    * Signals progress_cond when this happens. */
+   uint64_t                                     present_submitted_count;
+   /* Total number of images ever pushed to a present queue. */
+   uint64_t                                     present_queue_push_count;
+   /* Total number of images returned to application in AcquireNextImage. */
+   uint64_t                                     present_poll_acquire_count;
+
    struct x11_image                             images[0];
 };
 VK_DEFINE_NONDISP_HANDLE_CASTS(x11_swapchain, base.base, VkSwapchainKHR,
                                VK_OBJECT_TYPE_SWAPCHAIN_KHR)
 
 static void x11_present_complete(struct x11_swapchain *swapchain,
-                                 struct x11_image *image, uint32_t index)
+                                 struct x11_image *image)
 {
-   uint64_t signal_present_id = image->pending_completions[index].signal_present_id;
-   if (signal_present_id) {
-      mtx_lock(&swapchain->present_progress_mutex);
-      if (signal_present_id > swapchain->present_id) {
-         swapchain->present_id = signal_present_id;
-         u_cnd_monotonic_broadcast(&swapchain->present_progress_cond);
+   if (image->present_id) {
+      pthread_mutex_lock(&swapchain->present_progress_mutex);
+      if (image->signal_present_id > swapchain->present_id) {
+         swapchain->present_id = image->signal_present_id;
+         pthread_cond_broadcast(&swapchain->present_progress_cond);
       }
-      mtx_unlock(&swapchain->present_progress_mutex);
-   }
-
-   image->present_queued_count--;
-   if (image->present_queued_count) {
-      memmove(image->pending_completions + index,
-              image->pending_completions + index + 1,
-              (image->present_queued_count - index) *
-              sizeof(image->pending_completions[0]));
+      pthread_mutex_unlock(&swapchain->present_progress_mutex);
    }
-
-   u_cnd_monotonic_signal(&swapchain->thread_state_cond);
 }
 
 static void x11_notify_pending_present(struct x11_swapchain *swapchain,
                                        struct x11_image *image)
 {
-   u_cnd_monotonic_signal(&swapchain->thread_state_cond);
+   if (image->present_id || !swapchain->has_acquire_queue) {
+      pthread_mutex_lock(&swapchain->present_progress_mutex);
+      if (image->present_id > swapchain->present_id_pending) {
+         /* Unblock any thread waiting for a presentID out of order. */
+         swapchain->present_id_pending = image->present_id;
+      }
+
+      /* If we don't have an acquire queue, we might need to let
+       * vkAcquireNextImageKHR call know that it is safe to poll for presentation events. */
+      swapchain->present_submitted_count++;
+
+      pthread_cond_broadcast(&swapchain->present_progress_cond);
+      pthread_mutex_unlock(&swapchain->present_progress_mutex);
+   }
+
+   /* It is possible that an IDLE is observed before PRESENT_COMPLETE when
+    * not flipping. In this case, reading image->present_id might be a race
+    * in the FIFO management thread. */
+   image->signal_present_id = image->present_id;
 }
 
-/* It is assumed that thread_state_lock is taken when calling this function. */
 static void x11_swapchain_notify_error(struct x11_swapchain *swapchain, VkResult result)
 {
-   mtx_lock(&swapchain->present_progress_mutex);
+   pthread_mutex_lock(&swapchain->present_progress_mutex);
    swapchain->present_id = UINT64_MAX;
+   swapchain->present_id_pending = UINT64_MAX;
    swapchain->present_progress_error = result;
-   u_cnd_monotonic_broadcast(&swapchain->present_progress_cond);
-   mtx_unlock(&swapchain->present_progress_mutex);
-   u_cnd_monotonic_broadcast(&swapchain->thread_state_cond);
+   pthread_cond_broadcast(&swapchain->present_progress_cond);
+   pthread_mutex_unlock(&swapchain->present_progress_mutex);
 }
 
 /**
@@ -1183,8 +987,6 @@ static void x11_swapchain_notify_error(struct x11_swapchain *swapchain, VkResult
  * We make sure to 'stick' more pessimistic statuses: an out-of-date error
  * is permanent once seen, and every subsequent call will return this. If
  * this has not been seen, success will be returned.
- *
- * It is assumed that thread_state_lock is taken when calling this function.
  */
 static VkResult
 _x11_swapchain_result(struct x11_swapchain *chain, VkResult result,
@@ -1238,33 +1040,6 @@ x11_get_wsi_image(struct wsi_swapchain *wsi_chain, uint32_t image_index)
    return &chain->images[image_index].base;
 }
 
-static bool
-wsi_x11_swapchain_query_dri3_modifiers_changed(struct x11_swapchain *chain);
-
-
-
-static VkResult
-x11_wait_for_explicit_sync_release_submission(struct x11_swapchain *chain,
-                                              uint64_t rel_timeout_ns,
-                                              uint32_t *image_index)
-{
-   STACK_ARRAY(struct wsi_image*, images, chain->base.image_count);
-   for (uint32_t i = 0; i < chain->base.image_count; i++)
-      images[i] = &chain->images[i].base;
-   VkResult result;
-#ifdef HAVE_LIBDRM
-   result = wsi_drm_wait_for_explicit_sync_release(&chain->base,
-                                                   chain->base.image_count,
-                                                   images,
-                                                   rel_timeout_ns,
-                                                  image_index);
-#else
-   result = VK_ERROR_FEATURE_NOT_PRESENT;
-#endif
-   STACK_ARRAY_FINISH(images);
-   return result;
-}
-
 /* XXX this belongs in presentproto */
 #ifndef PresentWindowDestroyed
 #define PresentWindowDestroyed (1 << 0)
@@ -1282,12 +1057,9 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
       if (config->pixmap_flags & PresentWindowDestroyed)
          return VK_ERROR_SURFACE_LOST_KHR;
 
-      struct wsi_device *wsi_device = (struct wsi_device *)chain->base.wsi;
-      if (!wsi_device->x11.ignore_suboptimal) {
-         if (config->width != chain->extent.width ||
-             config->height != chain->extent.height)
-            return VK_SUBOPTIMAL_KHR;
-      }
+      if (config->width != chain->extent.width ||
+          config->height != chain->extent.height)
+         return VK_SUBOPTIMAL_KHR;
 
       break;
    }
@@ -1295,12 +1067,13 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
    case XCB_PRESENT_EVENT_IDLE_NOTIFY: {
       xcb_present_idle_notify_event_t *idle = (void *) event;
 
-      assert(!chain->base.image_info.explicit_sync);
       for (unsigned i = 0; i < chain->base.image_count; i++) {
          if (chain->images[i].pixmap == idle->pixmap) {
+            chain->images[i].busy = false;
             chain->sent_image_count--;
             assert(chain->sent_image_count >= 0);
-            wsi_queue_push(&chain->acquire_queue, i);
+            if (chain->has_acquire_queue)
+               wsi_queue_push(&chain->acquire_queue, i);
             break;
          }
       }
@@ -1311,24 +1084,18 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
    case XCB_PRESENT_EVENT_COMPLETE_NOTIFY: {
       xcb_present_complete_notify_event_t *complete = (void *) event;
       if (complete->kind == XCB_PRESENT_COMPLETE_KIND_PIXMAP) {
-         unsigned i, j;
+         unsigned i;
          for (i = 0; i < chain->base.image_count; i++) {
             struct x11_image *image = &chain->images[i];
-            for (j = 0; j < image->present_queued_count; j++) {
-               if (image->pending_completions[j].serial == complete->serial) {
-                  x11_present_complete(chain, image, j);
-               }
+            if (image->present_queued && image->serial == complete->serial) {
+               x11_present_complete(chain, &chain->images[i]);
+               image->present_queued = false;
             }
          }
          chain->last_present_msc = complete->msc;
       }
 
       VkResult result = VK_SUCCESS;
-
-      struct wsi_device *wsi_device = (struct wsi_device *)chain->base.wsi;
-      if (wsi_device->x11.ignore_suboptimal)
-         return result;
-
       switch (complete->mode) {
       case XCB_PRESENT_COMPLETE_MODE_COPY:
          if (chain->copy_is_suboptimal)
@@ -1346,14 +1113,7 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
          /* The winsys is now trying to flip directly and cannot due to our
           * configuration. Request the user reallocate.
           */
-
-         /* Sometimes, this complete mode is spurious, and a false positive.
-          * Xwayland may report SUBOPTIMAL_COPY even if there are no changes in the modifiers.
-          * https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/26616 for more details. */
-         if (chain->status == VK_SUCCESS &&
-             wsi_x11_swapchain_query_dri3_modifiers_changed(chain)) {
-            result = VK_SUBOPTIMAL_KHR;
-         }
+         result = VK_SUBOPTIMAL_KHR;
          break;
 #endif
       default:
@@ -1370,12 +1130,284 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
    return VK_SUCCESS;
 }
 
+static VkResult
+x11_poll_for_special_event(struct x11_swapchain *chain, uint64_t abs_timeout, xcb_generic_event_t **out_event)
+{
+   /* Start out with 1 ms intervals since that's what poll() supports. */
+   uint64_t poll_busywait_ns = 1000 * 1000;
+   xcb_generic_event_t *event;
+   uint64_t rel_timeout;
+   struct pollfd pfds;
+
+   assert(abs_timeout != UINT64_MAX);
+
+   /* abs_timeout is assumed to be in timebase of os_time_get_absolute_timeout(). */
+
+   /* See comments in x11_manage_fifo_queues about problems with xcb_poll followed by poll().
+    * This path is suboptimal for scenarios where we're doing:
+    * - IMMEDIATE / MAILBOX (no acquire queue) and
+    * - Timeout that is neither 0 nor UINT64_MAX (very rare).
+    * The only real solution is a busy-poll scheme to ensure we don't sleep for too long.
+    * In a forward progress scenario, the XCB FD will be written at least once per frame,
+    * so we expect frequent wake-ups either way.
+    * This is a best-effort pragmatic solution until we have a proper solution in XCB.
+    */
+
+   rel_timeout = abs_timeout;
+   *out_event = NULL;
+   event = NULL;
+
+   while (1) {
+      event = xcb_poll_for_special_event(chain->conn, chain->special_event);
+
+      if (event || rel_timeout == 0)
+         break;
+
+      /* If a non-special event happens, the fd will still
+       * poll. So recalculate the timeout now just in case.
+       */
+      uint64_t current_time = os_time_get_nano();
+      if (abs_timeout > current_time)
+         rel_timeout = MIN2(poll_busywait_ns, abs_timeout - current_time);
+      else
+         rel_timeout = 0;
+
+      if (rel_timeout) {
+         pfds.fd = xcb_get_file_descriptor(chain->conn);
+         pfds.events = POLLIN;
+         int ret = poll(&pfds, 1, MAX2(rel_timeout / 1000 / 1000, 1u));
+         if (ret == -1)
+            return VK_ERROR_OUT_OF_DATE_KHR;
+
+         /* Gradually increase the poll duration if it takes a very long time to receive a poll event,
+          * since at that point, stutter isn't really the main concern anymore.
+          * We generally expect a special event to be received once every refresh duration. */
+         poll_busywait_ns += poll_busywait_ns / 2;
+         poll_busywait_ns = MIN2(10ull * 1000ull * 1000ull, poll_busywait_ns);
+      }
+   }
+
+   *out_event = event;
+   return event ? VK_SUCCESS : VK_TIMEOUT;
+}
+
+static bool
+x11_acquire_next_image_poll_has_forward_progress(struct x11_swapchain *chain)
+{
+   /* We have forward progress in the sense that we just error out. */
+   if (chain->present_progress_error != VK_SUCCESS)
+      return true;
+
+   /* If we got here, there are no available images.
+    * Some images might be acquired, but not submitted.
+    * Some images might be submitted to FIFO thread, but not submitted to X yet. */
+
+   /* If application holds on to images without presenting, it affects forward progress.
+    * If application holds on to too many images, forward progress may be impossible.
+    * Application is allowed to call acquire with timeout in these scenarios, but not UINT64_MAX, since it may deadlock. */
+   assert(chain->present_poll_acquire_count >= chain->present_queue_push_count);
+   unsigned application_owned_images = chain->present_poll_acquire_count - chain->present_queue_push_count;
+   assert(application_owned_images <= chain->base.image_count);
+
+   const unsigned minimum_images = 2;
+
+   /* To observe an IDLE event, we must have submitted at least 2 present requests to X.
+    * The first present may replace another swapchain's image, but it cannot IDLE one of our own.
+    * Refuse forward progress until we have observed two completed present requests.
+    * If we are in a steady state, we only need one present to be able to idle the current image.
+    * In a blit style composition (windowed mode), images may be idled immediately, so this requirement is relaxed,
+    * but we have to assume the worst case of FLIP model where the front buffer holds on to one of the swapchain images. */
+   if (chain->present_submitted_count < minimum_images)
+      return false;
+
+   /* Since there are no available images, all images not owned by application have been pushed to FIFO thread.
+    * There must be at least 2 presents queued up. */
+   unsigned present_queued_images = chain->base.image_count - application_owned_images;
+   if (present_queued_images < minimum_images)
+      return false;
+
+   /* Present queue must have caught up. */
+   return (chain->present_queue_push_count - chain->present_submitted_count) <=
+          (present_queued_images - minimum_images);
+}
+
+static VkResult
+x11_acquire_next_image_poll_find_index(struct x11_swapchain *chain, uint32_t *image_index)
+{
+   /* We don't need a lock here. AcquireNextImageKHR cannot be called concurrently,
+   * and busy flag is atomic. */
+   for (uint32_t i = 0; i < chain->base.image_count; i++) {
+      if (!chain->images[i].busy) {
+         /* We found a non-busy image */
+         xcb_sync_await_fence(chain->conn, 1, &chain->images[i].sync_fence);
+         *image_index = i;
+         chain->images[i].busy = true;
+         chain->present_poll_acquire_count++;
+         return x11_swapchain_result(chain, VK_SUCCESS);
+      }
+   }
+
+   return x11_swapchain_result(chain, VK_NOT_READY);
+}
+
+/**
+ * Acquire a ready-to-use image directly from our swapchain. If all images are
+ * busy wait until one is not anymore or till timeout.
+ */
+static VkResult
+x11_acquire_next_image_poll_x11(struct x11_swapchain *chain,
+                                uint32_t *image_index, uint64_t timeout)
+{
+   struct timespec rel_timeout, abs_timespec_realtime, start_time;
+   xcb_generic_event_t *event;
+   VkResult result;
+
+   /* If another thread is pumping the event queue, and we're polling with timeout == 0,
+    * try a quick poll before we try to take any locks. */
+   result = x11_acquire_next_image_poll_find_index(chain, image_index);
+   if (result != VK_NOT_READY)
+      return result;
+
+   uint64_t atimeout;
+   if (timeout == 0 || timeout == UINT64_MAX)
+      atimeout = timeout;
+   else
+      atimeout = os_time_get_absolute_timeout(timeout);
+
+   /* Mutex abs_timeout is in REALTIME timebase. */
+   timespec_from_nsec(&rel_timeout, timeout);
+   clock_gettime(CLOCK_REALTIME, &start_time);
+   timespec_add(&abs_timespec_realtime, &rel_timeout, &start_time);
+
+   if (chain->has_present_queue) {
+      /* If we have a present queue (but no acquire queue),
+       * we might need the present queue to complete
+       * a request before we can guarantee forward progress in the poll loop below.
+       * We take the poll_mutex, but so does the present queue. */
+      pthread_mutex_lock(&chain->present_progress_mutex);
+
+      /* There must be at least one present in-flight that has been committed to X,
+       * otherwise we can never satisfy the acquire operation if all images are busy,
+       * since we would be waiting on an event that will never happen. */
+      struct timespec abs_timespec;
+      timespec_from_nsec(&abs_timespec, atimeout);
+      result = VK_SUCCESS;
+
+      while (!x11_acquire_next_image_poll_has_forward_progress(chain)) {
+         int ret = pthread_cond_timedwait(&chain->present_progress_cond, &chain->present_progress_mutex, &abs_timespec);
+
+         if (ret == ETIMEDOUT) {
+            result = x11_swapchain_result(chain, timeout == 0 ? VK_NOT_READY : VK_TIMEOUT);
+            break;
+         }
+
+         if (ret) {
+            result = VK_ERROR_DEVICE_LOST;
+            break;
+         }
+      }
+
+      if (result == VK_SUCCESS && chain->present_progress_error != VK_SUCCESS)
+         result = chain->present_progress_error;
+
+      pthread_mutex_unlock(&chain->present_progress_mutex);
+
+      if (result != VK_SUCCESS)
+         return result;
+   }
+
+   int ret;
+   if (timeout == UINT64_MAX)
+      ret = pthread_mutex_lock(&chain->present_poll_mutex);
+   else
+      ret = pthread_mutex_timedlock(&chain->present_poll_mutex, &abs_timespec_realtime);
+
+   if (ret) {
+      if (ret == ETIMEDOUT)
+         return timeout == 0 ? VK_NOT_READY : VK_TIMEOUT;
+      else
+         return VK_ERROR_DEVICE_LOST;
+   }
+
+   while (1) {
+      result = x11_acquire_next_image_poll_find_index(chain, image_index);
+      if (result != VK_NOT_READY)
+         goto out_unlock;
+
+      xcb_flush(chain->conn);
+
+      if (timeout == UINT64_MAX) {
+         /* See comments in x11_manage_fifo_queues about problem scenarios with this call. */
+         event = xcb_wait_for_special_event(chain->conn, chain->special_event);
+         if (!event) {
+            result = x11_swapchain_result(chain, VK_ERROR_SURFACE_LOST_KHR);
+            goto out_unlock;
+         }
+      } else {
+         result = x11_poll_for_special_event(chain, atimeout, &event);
+         if (result == VK_TIMEOUT) {
+            /* AcquireNextImageKHR reserves a special return value for 0 timeouts. */
+            result = x11_swapchain_result(chain, timeout == 0 ? VK_NOT_READY : VK_TIMEOUT);
+            goto out_unlock;
+         } else if (result != VK_SUCCESS) {
+            result = x11_swapchain_result(chain, result);
+            goto out_unlock;
+         }
+      }
+
+      /* Update the swapchain status here. We may catch non-fatal errors here,
+       * in which case we need to update the status and continue.
+       */
+      result = x11_handle_dri3_present_event(chain, (void *)event);
+      /* Ensure that VK_SUBOPTIMAL_KHR is reported to the application */
+      result = x11_swapchain_result(chain, result);
+      free(event);
+      if (result < 0)
+         goto out_unlock;
+   }
+
+out_unlock:
+   pthread_mutex_unlock(&chain->present_poll_mutex);
+   return result;
+}
+
+/**
+ * Acquire a ready-to-use image from the acquire-queue. Only relevant in fifo
+ * presentation mode.
+ */
+static VkResult
+x11_acquire_next_image_from_queue(struct x11_swapchain *chain,
+                                  uint32_t *image_index_out, uint64_t timeout)
+{
+   assert(chain->has_acquire_queue);
+
+   uint32_t image_index;
+   VkResult result = wsi_queue_pull(&chain->acquire_queue,
+                                    &image_index, timeout);
+   if (result < 0 || result == VK_TIMEOUT) {
+      /* On error, the thread has shut down, so safe to update chain->status.
+       * Calling x11_swapchain_result with VK_TIMEOUT won't modify
+       * chain->status so that is also safe.
+       */
+      return x11_swapchain_result(chain, result);
+   } else if (chain->status < 0) {
+      return chain->status;
+   }
+
+   assert(image_index < chain->base.image_count);
+   xcb_sync_await_fence(chain->conn, 1, &chain->images[image_index].sync_fence);
+
+   *image_index_out = image_index;
+
+   return chain->status;
+}
+
 /**
  * Send image to X server via Present extension.
  */
 static VkResult
 x11_present_to_x11_dri3(struct x11_swapchain *chain, uint32_t image_index,
-                        uint64_t target_msc, VkPresentModeKHR present_mode)
+                        uint64_t target_msc)
 {
    struct x11_image *image = &chain->images[image_index];
 
@@ -1391,82 +1423,60 @@ x11_present_to_x11_dri3(struct x11_swapchain *chain, uint32_t image_index,
    if (!wsi_conn)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-   if (present_mode == VK_PRESENT_MODE_IMMEDIATE_KHR ||
-       (present_mode == VK_PRESENT_MODE_MAILBOX_KHR &&
-        wsi_conn->is_xwayland) ||
-       present_mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR)
+   if (chain->base.present_mode == VK_PRESENT_MODE_IMMEDIATE_KHR ||
+       chain->base.present_mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR)
       options |= XCB_PRESENT_OPTION_ASYNC;
 
-   if (present_mode == VK_PRESENT_MODE_IMMEDIATE_KHR
-      && chain->has_async_may_tear)
-      options |= XCB_PRESENT_OPTION_ASYNC_MAY_TEAR;
-
 #ifdef HAVE_DRI3_MODIFIERS
    if (chain->has_dri3_modifiers)
       options |= XCB_PRESENT_OPTION_SUBOPTIMAL;
 #endif
 
-   xshmfence_reset(image->shm_fence);
-
-   if (!chain->base.image_info.explicit_sync) {
-      ++chain->sent_image_count;
-      assert(chain->sent_image_count <= chain->base.image_count);
+   /* Poll for any available event and update the swapchain status. This could
+    * update the status of the swapchain to SUBOPTIMAL or OUT_OF_DATE if the
+    * associated X11 surface has been resized.
+    */
+   xcb_generic_event_t *event;
+   while ((event = xcb_poll_for_special_event(chain->conn, chain->special_event))) {
+      VkResult result = x11_handle_dri3_present_event(chain, (void *)event);
+      /* Ensure that VK_SUBOPTIMAL_KHR is reported to the application */
+      result = x11_swapchain_result(chain, result);
+      free(event);
+      if (result < 0)
+         return result;
    }
 
-   ++chain->send_sbc;
-   uint32_t serial = (uint32_t)chain->send_sbc;
+   xcb_sync_reset_fence(chain->conn, image->sync_fence);
 
-   assert(image->present_queued_count < ARRAY_SIZE(image->pending_completions));
-   image->pending_completions[image->present_queued_count++] =
-      (struct x11_image_pending_completion) {
-         .signal_present_id = image->present_id,
-         .serial = serial,
-      };
+   ++chain->sent_image_count;
+   assert(chain->sent_image_count <= chain->base.image_count);
 
-   xcb_void_cookie_t cookie;
-#ifdef HAVE_DRI3_EXPLICIT_SYNC
-   if (chain->base.image_info.explicit_sync) {
-      uint64_t acquire_point = image->base.explicit_sync[WSI_ES_ACQUIRE].timeline;
-      uint64_t release_point = image->base.explicit_sync[WSI_ES_RELEASE].timeline;
-      cookie = xcb_present_pixmap_synced(
-         chain->conn,
-         chain->window,
-         image->pixmap,
-         serial,
-         0,                                   /* valid */
-         image->update_area,                  /* update */
-         0,                                   /* x_off */
-         0,                                   /* y_off */
-         XCB_NONE,                            /* target_crtc */
-         image->dri3_syncobj[WSI_ES_ACQUIRE], /* acquire_syncobj */
-         image->dri3_syncobj[WSI_ES_RELEASE], /* release_syncobj */
-         acquire_point,
-         release_point,
-         options,
-         target_msc,
-         divisor,
-         remainder, 0, NULL);
-   } else
-#endif
-   {
-      cookie = xcb_present_pixmap(chain->conn,
-                                  chain->window,
-                                  image->pixmap,
-                                  serial,
-                                  0,                  /* valid */
-                                  image->update_area, /* update */
-                                  0,                  /* x_off */
-                                  0,                  /* y_off */
-                                  XCB_NONE,           /* target_crtc */
-                                  XCB_NONE,
-                                  image->sync_fence,
-                                  options,
-                                  target_msc,
-                                  divisor,
-                                  remainder, 0, NULL);
+   ++chain->send_sbc;
+   image->present_queued = true;
+   image->serial = (uint32_t) chain->send_sbc;
+
+   xcb_void_cookie_t cookie =
+      xcb_present_pixmap_checked(chain->conn,
+                                 chain->window,
+                                 image->pixmap,
+                                 image->serial,
+                                 0,                            /* valid */
+                                 XCB_NONE,           		   /* update */
+                                 0,                            /* x_off */
+                                 0,                            /* y_off */
+                                 XCB_NONE,                     /* target_crtc */
+                                 XCB_NONE,
+                                 image->sync_fence,
+                                 options,
+                                 target_msc,
+                                 divisor,
+                                 remainder, 0, NULL);
+   xcb_generic_error_t *error = xcb_request_check(chain->conn, cookie);
+   if (error) {
+      free(error);
+      return x11_swapchain_result(chain, VK_ERROR_SURFACE_LOST_KHR);
    }
-   xcb_discard_reply(chain->conn, cookie.sequence);
-   xcb_flush(chain->conn);
+
    return x11_swapchain_result(chain, VK_SUCCESS);
 }
 
@@ -1474,263 +1484,92 @@ x11_present_to_x11_dri3(struct x11_swapchain *chain, uint32_t image_index,
  * Send image to X server unaccelerated (software drivers).
  */
 static VkResult
-x11_present_to_x11_sw(struct x11_swapchain *chain, uint32_t image_index)
+x11_present_to_x11_sw(struct x11_swapchain *chain, uint32_t image_index,
+                      uint64_t target_msc)
 {
-   assert(!chain->base.image_info.explicit_sync);
    struct x11_image *image = &chain->images[image_index];
-
-   /* Begin querying this before submitting the frame for improved async performance.
-    * In this _sw() mode we're expecting network round-trip delay, not just UNIX socket delay. */
-   xcb_get_geometry_cookie_t geom_cookie = xcb_get_geometry(chain->conn, chain->window);
-
    xcb_void_cookie_t cookie;
-   void *myptr = image->base.cpu_map;
-   size_t hdr_len = sizeof(xcb_put_image_request_t);
-   int stride_b = image->base.row_pitches[0];
-   size_t size = (hdr_len + stride_b * chain->extent.height) >> 2;
-   uint64_t max_req_len = xcb_get_maximum_request_length(chain->conn);
-
-   if (image->rectangle_count > 0) {
-      for (int i = 0; i < image->rectangle_count; i++) {
-         xcb_rectangle_t rect = chain->images[image_index].rects[i];
-         const uint8_t *data = (const uint8_t*)myptr + (rect.y * stride_b) + (rect.x * 4);
-         for (int j = 0; j < rect.height; j++) {
-            cookie = xcb_put_image(chain->conn, XCB_IMAGE_FORMAT_Z_PIXMAP,
-                                   chain->window, chain->gc,
-                                   rect.width,
-                                   1,
-                                   rect.x, rect.y + j,
-                                   0, chain->depth,
-                                   rect.width * 4,
-                                   data);
-            xcb_discard_reply(chain->conn, cookie.sequence);
-            data += stride_b;
-         }
-      }
-   } else if (size < max_req_len) {
+   
+   if (chain->has_mit_shm) {
+      memcpy(image->shmaddr, image->base.cpu_map, image->base.row_pitches[0] * chain->extent.height);
+      cookie = xcb_shm_put_image(chain->conn,
+                                 chain->window,
+								 chain->gc,
+								 image->base.row_pitches[0] / 4,
+								 chain->extent.height,
+								 0, 0,
+								 chain->extent.width,
+								 chain->extent.height,
+								 0, 0, chain->depth, XCB_IMAGE_FORMAT_Z_PIXMAP, 
+								 0,
+								 image->shmseg,
+								 0);
+      xcb_discard_reply(chain->conn, cookie.sequence);	   
+   }
+   else {
       cookie = xcb_put_image(chain->conn, XCB_IMAGE_FORMAT_Z_PIXMAP,
                              chain->window,
                              chain->gc,
                              image->base.row_pitches[0] / 4,
                              chain->extent.height,
-                             0,0,0,chain->depth,
+                             0, 0, 0, chain->depth,
                              image->base.row_pitches[0] * chain->extent.height,
                              image->base.cpu_map);
       xcb_discard_reply(chain->conn, cookie.sequence);
-   } else {
-      int num_lines = ((max_req_len << 2) - hdr_len) / stride_b;
-      int y_start = 0;
-      int y_todo = chain->extent.height;
-      while (y_todo) {
-         int this_lines = MIN2(num_lines, y_todo);
-         cookie = xcb_put_image(chain->conn, XCB_IMAGE_FORMAT_Z_PIXMAP,
-                                chain->window,
-                                chain->gc,
-                                image->base.row_pitches[0] / 4,
-                                this_lines,
-                                0,y_start,0,chain->depth,
-                                this_lines * stride_b,
-                                (const uint8_t *)myptr + (y_start * stride_b));
-         xcb_discard_reply(chain->conn, cookie.sequence);
-         y_start += this_lines;
-         y_todo -= this_lines;
-      }
    }
-
+   
    xcb_flush(chain->conn);
+   image->busy = false;
+   return VK_SUCCESS;  
+}
 
-   /* We don't have queued present here.
-    * Immediately let application acquire again, but query geometry first so
-    * we can report OUT_OF_DATE on resize. */
-   xcb_generic_error_t *err;
+/**
+ * Send image to the X server for presentation at target_msc.
+ */
+static VkResult
+x11_present_to_x11(struct x11_swapchain *chain, uint32_t image_index,
+                   uint64_t target_msc)
+{
+   VkResult result;
+   if (chain->base.wsi->sw)
+      result = x11_present_to_x11_sw(chain, image_index, target_msc);
+   else
+      result = x11_present_to_x11_dri3(chain, image_index, target_msc);
 
-   xcb_get_geometry_reply_t *geom = xcb_get_geometry_reply(chain->conn, geom_cookie, &err);
-   VkResult result = VK_SUCCESS;
-   if (geom) {
-      if (chain->extent.width != geom->width ||
-          chain->extent.height != geom->height)
-         result = VK_ERROR_OUT_OF_DATE_KHR;
-   } else {
-      result = VK_ERROR_SURFACE_LOST_KHR;
-   }
-   free(err);
-   free(geom);
+   if (result < 0)
+      x11_swapchain_notify_error(chain, result);
+   else
+      x11_notify_pending_present(chain, &chain->images[image_index]);
 
-   wsi_queue_push(&chain->acquire_queue, image_index);
    return result;
 }
 
-static void
-x11_capture_trace(struct x11_swapchain *chain)
-{
-#ifdef XCB_KEYSYMS_AVAILABLE
-   VK_FROM_HANDLE(vk_device, device, chain->base.device);
-   if (!device->physical->instance->trace_mode)
-      return;
-
-   xcb_query_keymap_cookie_t keys_cookie = xcb_query_keymap(chain->conn);
-
-   xcb_generic_error_t *error = NULL;
-   xcb_query_keymap_reply_t *keys = xcb_query_keymap_reply(chain->conn, keys_cookie, &error);
-   if (error) {
-      free(error);
-      return;
-   }
-
-   xcb_key_symbols_t *key_symbols = xcb_key_symbols_alloc(chain->conn);
-   xcb_keycode_t *keycodes = xcb_key_symbols_get_keycode(key_symbols, XK_F1);
-   if (keycodes) {
-      xcb_keycode_t keycode = keycodes[0];
-      free(keycodes);
-
-      simple_mtx_lock(&device->trace_mtx);
-      bool capture_key_pressed = keys->keys[keycode / 8] & (1u << (keycode % 8));
-      device->trace_hotkey_trigger = capture_key_pressed && (capture_key_pressed != chain->base.capture_key_pressed);
-      chain->base.capture_key_pressed = capture_key_pressed;
-      simple_mtx_unlock(&device->trace_mtx);
-   }
-
-   xcb_key_symbols_free(key_symbols);
-   free(keys);
-#endif
-}
-
-/* Use a trivial helper here to make it easier to read in code
- * where we're intending to access chain->status outside the thread lock. */
-static VkResult x11_swapchain_read_status_atomic(struct x11_swapchain *chain)
-{
-   return chain->status;
-}
-
-/**
- * Decides if an early wait on buffer fences before buffer submission is required.
- * That is for mailbox mode, as otherwise the latest image in the queue might not be fully rendered at
- * present time, which could lead to missing a frame. This is an Xorg issue.
- *
- * On Wayland compositors, this used to be a problem as well, but not anymore,
- * and this check assumes that Mesa is running on a reasonable compositor.
- * The wait behavior can be forced by setting the 'vk_xwayland_wait_ready' DRIConf option to true.
- * Some drivers, like e.g. Venus may still want to require wait_ready by default,
- * so the option is kept around for now.
- *
- * On Wayland, we don't know at this point if tearing protocol is/can be used by Xwl,
- * so we have to make the MAILBOX assumption.
- */
-static bool
-x11_needs_wait_for_fences(const struct wsi_device *wsi_device,
-                          struct wsi_x11_connection *wsi_conn,
-                          VkPresentModeKHR present_mode)
-{
-   if (wsi_conn->is_xwayland && !wsi_device->x11.xwaylandWaitReady) {
-      return false;
-   }
-
-   switch (present_mode) {
-      case VK_PRESENT_MODE_MAILBOX_KHR:
-         return true;
-      case VK_PRESENT_MODE_IMMEDIATE_KHR:
-         return wsi_conn->is_xwayland;
-      default:
-         return false;
-   }
-}
-
-/* This matches Wayland. */
-#define X11_SWAPCHAIN_MAILBOX_IMAGES 4
-
-static bool
-x11_requires_mailbox_image_count(const struct wsi_device *device,
-                                 struct wsi_x11_connection *wsi_conn,
-                                 VkPresentModeKHR present_mode)
-{
-   /* If we're resorting to wait for fences, we're assuming a MAILBOX-like model,
-    * and we should allocate accordingly.
-    *
-    * One potential concern here is IMMEDIATE mode on Wayland.
-    * This situation could arise:
-    * - Fullscreen FLIP mode
-    * - Compositor does not support tearing protocol (we cannot know this here)
-    *
-    * With 3 images, during the window between latch and flip, there is only one image left to app,
-    * so peak FPS may not be reached if the window between latch and flip is large,
-    * but tests on contemporary compositors suggest this effect is minor.
-    * Frame rate in the thousands can easily be reached.
-    *
-    * There are pragmatic reasons to expose 3 images for IMMEDIATE on Xwl.
-    * - minImageCount is not intended as a tool to tune performance, its intent is to signal forward progress.
-    *   Our X11 and WL implementations do so for pragmatic reasons due to sync acquire interacting poorly with 2 images.
-    *   A jump from 3 to 4 is at best a minor improvement which only affects applications
-    *   running at extremely high frame rates, way beyond the monitor refresh rate.
-    *   On the other hand, lowering minImageCount to 2 would break the fundamental idea of MAILBOX
-    *   (and IMMEDIATE without tear), since FPS > refresh rate would not be possible.
-    *
-    * - Several games developed for other platforms and other Linux WSI implementations
-    *   do not expect that image counts arbitrarily change when changing present mode,
-    *   and will crash when Mesa does so.
-    *   There are several games using the strict_image_count drirc to work around this,
-    *   and it would be good to be friendlier in the first place, so we don't have to work around more games.
-    *   IMMEDIATE is a common presentation mode on those platforms, but MAILBOX is more Wayland-centric in nature,
-    *   so increasing image count for that mode is more reasonable.
-    *
-    * - IMMEDIATE expects tearing, and when tearing, 3 images are more than enough.
-    *
-    * - With EXT_swapchain_maintenance1, toggling between FIFO / IMMEDIATE (used extensively by D3D layering)
-    *   would require application to allocate >3 images which is unfortunate for memory usage,
-    *   and potentially disastrous for latency unless KHR_present_wait is used.
-    */
-   return x11_needs_wait_for_fences(device, wsi_conn, present_mode) ||
-          present_mode == VK_PRESENT_MODE_MAILBOX_KHR;
-}
-
-/**
- * Send image to the X server for presentation at target_msc.
- */
-static VkResult
-x11_present_to_x11(struct x11_swapchain *chain, uint32_t image_index,
-                   uint64_t target_msc, VkPresentModeKHR present_mode)
-{
-   x11_capture_trace(chain);
-
-   VkResult result;
-   if (chain->base.wsi->sw && !chain->has_mit_shm)
-      result = x11_present_to_x11_sw(chain, image_index);
-   else
-      result = x11_present_to_x11_dri3(chain, image_index, target_msc, present_mode);
-
-   if (result < 0)
-      x11_swapchain_notify_error(chain, result);
-   else
-      x11_notify_pending_present(chain, &chain->images[image_index]);
-
-   return result;
-}
-
-static VkResult
-x11_release_images(struct wsi_swapchain *wsi_chain,
-                   uint32_t count, const uint32_t *indices)
+static VkResult
+x11_release_images(struct wsi_swapchain *wsi_chain,
+                   uint32_t count, const uint32_t *indices)
 {
    struct x11_swapchain *chain = (struct x11_swapchain *)wsi_chain;
    if (chain->status == VK_ERROR_SURFACE_LOST_KHR)
       return chain->status;
 
-   /* If we're using implicit sync, push images to the acquire queue */
-   if (!chain->base.image_info.explicit_sync) {
-      for (uint32_t i = 0; i < count; i++) {
-         uint32_t index = indices[i];
-         assert(index < chain->base.image_count);
+   for (uint32_t i = 0; i < count; i++) {
+      uint32_t index = indices[i];
+      assert(index < chain->base.image_count);
+
+      if (chain->has_acquire_queue) {
          wsi_queue_push(&chain->acquire_queue, index);
+      } else {
+         assert(chain->images[index].busy);
+         chain->images[index].busy = false;
       }
    }
 
-   return VK_SUCCESS;
-}
+   if (!chain->has_acquire_queue) {
+      assert(chain->present_poll_acquire_count >= count);
+      chain->present_poll_acquire_count -= count;
+   }
 
-static void
-x11_set_present_mode(struct wsi_swapchain *wsi_chain,
-                     VkPresentModeKHR mode)
-{
-   struct x11_swapchain *chain = (struct x11_swapchain *)wsi_chain;
-   chain->base.present_mode = mode;
+   return VK_SUCCESS;
 }
 
 /**
@@ -1748,38 +1587,40 @@ x11_acquire_next_image(struct wsi_swapchain *anv_chain,
    uint64_t timeout = info->timeout;
 
    /* If the swapchain is in an error state, don't go any further. */
-   VkResult result = x11_swapchain_read_status_atomic(chain);
-   if (result < 0)
-      return result;
+   if (chain->status < 0)
+      return chain->status;
 
-   if (chain->base.image_info.explicit_sync) {
-      result = x11_wait_for_explicit_sync_release_submission(chain, timeout,
-                                                             image_index);
-   } else {
-      result = wsi_queue_pull(&chain->acquire_queue,
-                              image_index, timeout);
+   if (chain->base.wsi->sw) {
+      for (unsigned i = 0; i < chain->base.image_count; i++) {
+         if (!chain->images[i].busy) {
+            *image_index = i;
+            chain->images[i].busy = true;
+            chain->present_poll_acquire_count++;
+            xcb_generic_error_t *err;
+
+            xcb_get_geometry_cookie_t geom_cookie = xcb_get_geometry(chain->conn, chain->window);
+            xcb_get_geometry_reply_t *geom = xcb_get_geometry_reply(chain->conn, geom_cookie, &err);
+            VkResult result = VK_SUCCESS;
+            if (geom) {
+               if (chain->extent.width != geom->width ||
+                   chain->extent.height != geom->height)
+                  result = VK_SUBOPTIMAL_KHR;
+            } else {
+               result = VK_ERROR_SURFACE_LOST_KHR;
+            }
+            free(err);
+            free(geom);
+            return result;
+         }
+      }
+      return VK_NOT_READY;
    }
 
-   if (result == VK_TIMEOUT)
-      return info->timeout ? VK_TIMEOUT : VK_NOT_READY;
-
-   if (result < 0) {
-      mtx_lock(&chain->thread_state_lock);
-      result = x11_swapchain_result(chain, result);
-      mtx_unlock(&chain->thread_state_lock);
+   if (chain->has_acquire_queue) {
+      return x11_acquire_next_image_from_queue(chain, image_index, timeout);
    } else {
-      result = x11_swapchain_read_status_atomic(chain);
+      return x11_acquire_next_image_poll_x11(chain, image_index, timeout);
    }
-
-   if (result < 0)
-      return result;
-
-   assert(*image_index < chain->base.image_count);
-   if (chain->images[*image_index].shm_fence &&
-       !chain->base.image_info.explicit_sync)
-      xshmfence_await(chain->images[*image_index].shm_fence);
-
-   return result;
 }
 
 /**
@@ -1796,38 +1637,40 @@ x11_queue_present(struct wsi_swapchain *anv_chain,
                   const VkPresentRegionKHR *damage)
 {
    struct x11_swapchain *chain = (struct x11_swapchain *)anv_chain;
-   xcb_xfixes_region_t update_area = 0;
 
    /* If the swapchain is in an error state, don't go any further. */
-   VkResult status = x11_swapchain_read_status_atomic(chain);
-   if (status < 0)
-      return status;
-
-   if (damage && damage->pRectangles && damage->rectangleCount > 0 &&
-      damage->rectangleCount <= MAX_DAMAGE_RECTS) {
-      xcb_rectangle_t *rects = chain->images[image_index].rects;
-
-      update_area = chain->images[image_index].update_region;
-      for (unsigned i = 0; i < damage->rectangleCount; i++) {
-         const VkRectLayerKHR *rect = &damage->pRectangles[i];
-         assert(rect->layer == 0);
-         rects[i].x = rect->offset.x;
-         rects[i].y = rect->offset.y;
-         rects[i].width = rect->extent.width;
-         rects[i].height = rect->extent.height;
-      }
-      xcb_xfixes_set_region(chain->conn, update_area, damage->rectangleCount, rects);
-      chain->images[image_index].rectangle_count = damage->rectangleCount;
+   if (chain->status < 0)
+      return chain->status;
+
+   chain->images[image_index].present_id = present_id;
+   chain->images[image_index].busy = true;
+   
+   if (chain->has_present_queue) {
+      wsi_queue_push(&chain->present_queue, image_index);
+      chain->present_queue_push_count++;
+      return chain->status;
    } else {
-      chain->images[image_index].rectangle_count = 0;
+      /* No present queue means immedate mode, so we present immediately. */
+      pthread_mutex_lock(&chain->present_poll_mutex);
+      VkResult result = x11_present_to_x11(chain, image_index, 0);
+      pthread_mutex_unlock(&chain->present_poll_mutex);
+      return result;
    }
-   chain->images[image_index].update_area = update_area;
-   chain->images[image_index].present_id = present_id;
-   /* With EXT_swapchain_maintenance1, the present mode can change per present. */
-   chain->images[image_index].present_mode = chain->base.present_mode;
+}
 
-   wsi_queue_push(&chain->present_queue, image_index);
-   return x11_swapchain_read_status_atomic(chain);
+static bool
+x11_needs_wait_for_fences(const struct wsi_device *wsi_device,
+                          struct wsi_x11_connection *wsi_conn,
+                          VkPresentModeKHR present_mode)
+{
+   switch (present_mode) {
+   case VK_PRESENT_MODE_MAILBOX_KHR:
+      return true;
+   case VK_PRESENT_MODE_IMMEDIATE_KHR:
+      return false;
+   default:
+      return false;
+   }
 }
 
 /**
@@ -1841,116 +1684,37 @@ static unsigned x11_driver_owned_images(const struct x11_swapchain *chain)
    return chain->base.image_count - chain->sent_image_count;
 }
 
-/* This thread is responsible for pumping PRESENT replies.
- * This is done in a separate thread from the X11 presentation thread
- * to be able to support non-blocking modes like IMMEDIATE and MAILBOX.
- * Frame completion events can happen at any time, and we need to handle
- * the events as soon as they come in to have a quality implementation.
- * The presentation thread may go to sleep waiting for new presentation events to come in,
- * and it cannot wait for both X events and application events at the same time.
- * If we only cared about FIFO, this thread wouldn't be very useful.
- * Earlier implementation of X11 WSI had a single FIFO thread that blocked on X events after presenting.
- * For IMMEDIATE and MAILBOX, the application thread pumped the event queue, which caused a lot of pain
- * when trying to deal with present wait.
- */
-static int
-x11_manage_event_queue(void *state)
-{
-   struct x11_swapchain *chain = state;
-   u_thread_setname("WSI swapchain event");
-
-   /* While there is an outstanding IDLE we should wait for it.
-    * In FLIP modes at most one image will not be driver owned eventually.
-    * In BLIT modes, we expect that all images will eventually be driver owned,
-    * but we don't know which mode is being used. */
-   unsigned forward_progress_guaranteed_acquired_images = chain->base.image_count - 1;
-
-   mtx_lock(&chain->thread_state_lock);
-
-   while (chain->status >= 0) {
-      /* This thread should only go sleep waiting for X events when we know there are pending events.
-       * We expect COMPLETION events when there is at least one image marked as present_queued.
-       * We also expect IDLE events, but we only consider waiting for them when all images are busy,
-       * and application has fewer than N images acquired. */
-
-      bool assume_forward_progress = false;
-
-      for (uint32_t i = 0; i < chain->base.image_count; i++) {
-         if (chain->images[i].present_queued_count != 0) {
-            /* We must pump through a present wait and unblock FIFO thread if using FIFO mode. */
-            assume_forward_progress = true;
-            break;
-         }
-      }
-
-      if (!assume_forward_progress && !chain->base.image_info.explicit_sync) {
-         /* If true, application expects acquire (IDLE) to happen in finite time. */
-         assume_forward_progress = x11_driver_owned_images(chain) <
-                                   forward_progress_guaranteed_acquired_images;
-      }
-
-      if (assume_forward_progress) {
-         /* Only yield lock when blocking on X11 event. */
-         mtx_unlock(&chain->thread_state_lock);
-         xcb_generic_event_t *event =
-               xcb_wait_for_special_event(chain->conn, chain->special_event);
-         mtx_lock(&chain->thread_state_lock);
-
-         /* Re-check status since we dropped the lock while waiting for X. */
-         VkResult result = chain->status;
-
-         if (result >= 0) {
-            if (event) {
-               /* Queue thread will be woken up if anything interesting happened in handler.
-                * Queue thread blocks on:
-                * - Presentation events completing
-                * - Presentation requests from application
-                * - WaitForFence workaround if applicable */
-               result = x11_handle_dri3_present_event(chain, (void *) event);
-            } else {
-               result = VK_ERROR_SURFACE_LOST_KHR;
-            }
-         }
-
-         /* Updates chain->status and wakes up threads as necessary on error. */
-         x11_swapchain_result(chain, result);
-         free(event);
-      } else {
-         /* Nothing important to do, go to sleep until queue thread wakes us up. */
-         u_cnd_monotonic_wait(&chain->thread_state_cond, &chain->thread_state_lock);
-      }
-   }
-
-   mtx_unlock(&chain->thread_state_lock);
-   return 0;
-}
-
 /**
- * Presentation thread.
+ * Our queue manager. Albeit called x11_manage_fifo_queues only directly
+ * manages the present-queue and does this in general in fifo and mailbox presentation modes.
  *
  * Runs in a separate thread, blocks and reacts to queued images on the
  * present-queue
  *
- * This must be a thread since we have to block in two cases:
- * - FIFO:
- *     We must wait for previous presentation to complete
- *     in some way so we can compute the target MSC.
- * - WaitForFence workaround:
- *     In some cases, we need to wait for image to complete rendering before submitting it to X.
+ * In mailbox mode the queue management is simplified since we only need to
+ * pull new images from the present queue and can directly present them.
+ *
+ * In fifo mode images can only be presented one after the other. For that after
+ * sending the image to the X server we wait until the image either has been
+ * presented or released and only then pull a new image from the present-queue.
  */
-static int
-x11_manage_present_queue(void *state)
+static void *
+x11_manage_fifo_queues(void *state)
 {
    struct x11_swapchain *chain = state;
    struct wsi_x11_connection *wsi_conn =
-         wsi_x11_get_connection((struct wsi_device*)chain->base.wsi, chain->conn);
+      wsi_x11_get_connection((struct wsi_device*)chain->base.wsi, chain->conn);
    VkResult result = VK_SUCCESS;
 
-   u_thread_setname("WSI swapchain queue");
+   assert(chain->has_present_queue);
 
-   uint64_t target_msc = 0;
+   u_thread_setname("WSI swapchain queue");
 
-   while (x11_swapchain_read_status_atomic(chain) >= 0) {
+   while (chain->status >= 0) {
+      /* We can block here unconditionally because after an image was sent to
+       * the server (later on in this loop) we ensure at least one image is
+       * acquirable by the consumer or wait there on such an event.
+       */
       uint32_t image_index = 0;
       {
          MESA_TRACE_SCOPE("pull present queue");
@@ -1958,76 +1722,119 @@ x11_manage_present_queue(void *state)
          assert(result != VK_TIMEOUT);
       }
 
-      /* The status can change underneath us if the swapchain is destroyed
-       * from another thread. */
-      if (result >= 0)
-         result = x11_swapchain_read_status_atomic(chain);
-      if (result < 0)
-         break;
-
-      VkPresentModeKHR present_mode = chain->images[image_index].present_mode;
+      if (result < 0) {
+         goto fail;
+      } else if (chain->status < 0) {
+         /* The status can change underneath us if the swapchain is destroyed
+          * from another thread.
+          */
+         return NULL;
+      }
 
+      /* Waiting for the GPU work to finish at this point in time is required in certain usage
+       * scenarios. Otherwise we wait as usual in wsi_common_queue_present.
+       */
       if (x11_needs_wait_for_fences(chain->base.wsi, wsi_conn,
-                                    present_mode) &&
-          /* not necessary with explicit sync */
-          !chain->base.image_info.explicit_sync) {
+                                    chain->base.present_mode)) {
          MESA_TRACE_SCOPE("wait fence");
          result = chain->base.wsi->WaitForFences(chain->base.device, 1,
-                                                 &chain->base.fences[image_index],
-                                                 true, UINT64_MAX);
+                                        &chain->base.fences[image_index],
+                                        true, UINT64_MAX);
          if (result != VK_SUCCESS) {
             result = VK_ERROR_OUT_OF_DATE_KHR;
-            break;
+            goto fail;
          }
       }
 
-      mtx_lock(&chain->thread_state_lock);
+      uint64_t target_msc = 0;
+      if (chain->has_acquire_queue)
+         target_msc = chain->last_present_msc + 1;
 
-      /* In IMMEDIATE and MAILBOX modes, there is a risk that we have exhausted the presentation queue,
-       * since IDLE could return multiple times before observing a COMPLETE. */
-      while (chain->status >= 0 &&
-             chain->images[image_index].present_queued_count ==
-             ARRAY_SIZE(chain->images[image_index].pending_completions)) {
-         u_cnd_monotonic_wait(&chain->thread_state_cond, &chain->thread_state_lock);
-      }
+      /* Locking here is only relevant if we don't have an acquire queue.
+       * WaitForPresentKHR will pump the message queue on its own unless
+       * has_acquire_queue and has_present_queue are both true. */
+      if (!chain->has_acquire_queue)
+         pthread_mutex_lock(&chain->present_poll_mutex);
+      result = x11_present_to_x11(chain, image_index, target_msc);
+      if (!chain->has_acquire_queue)
+         pthread_mutex_unlock(&chain->present_poll_mutex);
 
-      if (chain->status < 0) {
-         mtx_unlock(&chain->thread_state_lock);
-         break;
-      }
+      if (result < 0)
+         goto fail;
 
-      result = x11_present_to_x11(chain, image_index, target_msc, present_mode);
+      if (chain->has_acquire_queue) {
+         MESA_TRACE_SCOPE("wait present");
 
-      if (result < 0) {
-         mtx_unlock(&chain->thread_state_lock);
-         break;
-      }
+         /* Assume this isn't a swapchain where we force 5 images, because those
+          * don't end up with an acquire queue at the moment.
+          */
+         unsigned min_image_count = x11_get_min_image_count(chain->base.wsi);
+
+         /* With drirc overrides some games have swapchain with less than
+          * minimum number of images. */
+         min_image_count = MIN2(min_image_count, chain->base.image_count);
+
+         /* We always need to ensure that the app can have this number of images
+          * acquired concurrently in between presents:
+          * "VUID-vkAcquireNextImageKHR-swapchain-01802
+          *  If the number of currently acquired images is greater than the difference
+          *  between the number of images in swapchain and the value of
+          *  VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to
+          *  vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to
+          *  create swapchain, timeout must not be UINT64_MAX"
+          */
+         unsigned forward_progress_guaranteed_acquired_images =
+            chain->base.image_count - min_image_count + 1;
 
-      if (present_mode == VK_PRESENT_MODE_FIFO_KHR ||
-          present_mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR) {
-         MESA_TRACE_SCOPE("wait present");
+         /* Wait for our presentation to occur and ensure we have at least one
+          * image that can be acquired by the client afterwards. This ensures we
+          * can pull on the present-queue on the next loop.
+          */
+         while (chain->images[image_index].present_queued ||
+                /* If we have images in the present queue the outer loop won't block and a break
+                 * here would end up at this loop again, otherwise a break here satisfies
+                 * VUID-vkAcquireNextImageKHR-swapchain-01802 */
+                x11_driver_owned_images(chain) < forward_progress_guaranteed_acquired_images) {
+
+            /* Calls to xcb_wait_for_special_event are broken by design due to a XCB flaw.
+             * This call may hang indefinitely if the X window is destroyed before the swapchain.
+             * An X window destruction does not trigger a special event here, unfortunately.
+             *
+             * A workaround was attempted in
+             * https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/13564#note_1121977, but
+             * was reverted due to its high CPU usage.
+             * No pragmatic solution exists that solves CPU usage and stutter problems.
+             *
+             * A xcb_poll call followed by poll() is a race condition if other threads read from the XCB connection FD
+             * between the xcb poll and fd poll(), even if it's completely unrelated to this event queue.
+             * poll() may end up waiting indefinitely even if the XCB event has been moved from the FD
+             * to chain->special_event queue.
+             * The proper fix is a wait_for_special_event_with_timeout, but it does not exist.
+             * See https://gitlab.freedesktop.org/xorg/lib/libxcb/-/merge_requests/9.
+             * For now, keep this approach. Applications are generally well-behaved. */
+            xcb_generic_event_t *event =
+               xcb_wait_for_special_event(chain->conn, chain->special_event);
+            if (!event) {
+               result = VK_ERROR_SURFACE_LOST_KHR;
+               goto fail;
+            }
 
-         while (chain->status >= 0 && chain->images[image_index].present_queued_count != 0) {
-            /* In FIFO mode, we need to make sure we observe a COMPLETE before queueing up
-             * another present. */
-            u_cnd_monotonic_wait(&chain->thread_state_cond, &chain->thread_state_lock);
+            result = x11_handle_dri3_present_event(chain, (void *)event);
+            /* Ensure that VK_SUBOPTIMAL_KHR is reported to the application */
+            result = x11_swapchain_result(chain, result);
+            free(event);
+            if (result < 0)
+               goto fail;
          }
-
-         /* If next present is not FIFO, we still need to ensure we don't override that
-          * present. If FIFO, we need to ensure MSC is larger than the COMPLETED frame. */
-         target_msc = chain->last_present_msc + 1;
       }
-
-      mtx_unlock(&chain->thread_state_lock);
    }
 
-   mtx_lock(&chain->thread_state_lock);
+fail:
    x11_swapchain_result(chain, result);
-   if (!chain->base.image_info.explicit_sync)
+   if (chain->has_acquire_queue)
       wsi_queue_push(&chain->acquire_queue, UINT32_MAX);
-   mtx_unlock(&chain->thread_state_lock);
 
-   return 0;
+   return NULL;
 }
 
 static uint8_t *
@@ -2060,23 +1867,21 @@ x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
                struct x11_image *image)
 {
    xcb_void_cookie_t cookie;
-   xcb_generic_error_t *error = NULL;
    VkResult result;
    uint32_t bpp = 32;
-   int fence_fd;
 
    result = wsi_create_image(&chain->base, &chain->base.image_info,
                              &image->base);
    if (result != VK_SUCCESS)
       return result;
 
-   image->update_region = xcb_generate_id(chain->conn);
-   xcb_xfixes_create_region(chain->conn, image->update_region, 0, NULL);
-
    if (chain->base.wsi->sw) {
       if (!chain->has_mit_shm) {
+         image->busy = false;
          return VK_SUCCESS;
       }
+	  
+      alloc_shm(&image->base, image->base.row_pitches[0] * chain->extent.height);	  
 
       image->shmseg = xcb_generate_id(chain->conn);
 
@@ -2084,16 +1889,9 @@ x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
                      image->shmseg,
                      image->shmid,
                      0);
-      image->pixmap = xcb_generate_id(chain->conn);
-      cookie = xcb_shm_create_pixmap_checked(chain->conn,
-                                             image->pixmap,
-                                             chain->window,
-                                             image->base.row_pitches[0] / 4,
-                                             pCreateInfo->imageExtent.height,
-                                             chain->depth,
-                                             image->shmseg, 0);
-      xcb_discard_reply(chain->conn, cookie.sequence);
-      goto out_fence;
+	  
+	  image->busy = false;
+      return VK_SUCCESS;		
    }
    image->pixmap = xcb_generate_id(chain->conn);
 
@@ -2132,6 +1930,8 @@ x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
                                               chain->depth, bpp,
                                               image->base.drm_modifier,
                                               fds);
+											  
+      xcb_discard_reply(chain->conn, cookie.sequence);											  
    } else
 #endif
    {
@@ -2143,75 +1943,21 @@ x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
       if (fd == -1)
          return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-      cookie =
-         xcb_dri3_pixmap_from_buffer_checked(chain->conn,
-                                             image->pixmap,
-                                             chain->window,
-                                             image->base.sizes[0],
-                                             pCreateInfo->imageExtent.width,
-                                             pCreateInfo->imageExtent.height,
-                                             image->base.row_pitches[0],
-                                             chain->depth, bpp, fd);
+      xcb_dri3_pixmap_from_buffer_checked(chain->conn,
+                                          image->pixmap,
+                                          chain->window,
+                                          image->base.sizes[0],
+                                          pCreateInfo->imageExtent.width,
+                                          pCreateInfo->imageExtent.height,
+                                          image->base.row_pitches[0],
+                                          chain->depth, bpp, fd);
    }
-
-   error = xcb_request_check(chain->conn, cookie);
-   if (error != NULL) {
-      free(error);
-      goto fail_image;
-   }
-
-#ifdef HAVE_DRI3_EXPLICIT_SYNC
-   if (chain->base.image_info.explicit_sync) {
-      for (uint32_t i = 0; i < WSI_ES_COUNT; i++) {
-         image->dri3_syncobj[i] = xcb_generate_id(chain->conn);
-         int fd = dup(image->base.explicit_sync[i].fd);
-         if (fd < 0)
-            goto fail_image;
-
-         cookie = xcb_dri3_import_syncobj_checked(chain->conn,
-                                                  image->dri3_syncobj[i],
-                                                  chain->window,
-                                                  fd /* libxcb closes the fd */);
-         error = xcb_request_check(chain->conn, cookie);
-         if (error != NULL) {
-            free(error);
-            goto fail_image;
-         }
-      }
-   }
-#endif
-
-out_fence:
-   fence_fd = xshmfence_alloc_shm();
-   if (fence_fd < 0)
-      goto fail_pixmap;
-
-   image->shm_fence = xshmfence_map_shm(fence_fd);
-   if (image->shm_fence == NULL)
-      goto fail_shmfence_alloc;
-
+   
    image->sync_fence = xcb_generate_id(chain->conn);
-   xcb_dri3_fence_from_fd(chain->conn,
-                          image->pixmap,
-                          image->sync_fence,
-                          false,
-                          fence_fd);
-
-   xshmfence_trigger(image->shm_fence);
-
+   xcb_sync_create_fence(chain->conn, image->pixmap, image->sync_fence, false);
+   xcb_sync_trigger_fence(chain->conn, image->sync_fence);
+   image->busy = false;
    return VK_SUCCESS;
-
-fail_shmfence_alloc:
-   close(fence_fd);
-
-fail_pixmap:
-   cookie = xcb_free_pixmap(chain->conn, image->pixmap);
-   xcb_discard_reply(chain->conn, cookie.sequence);
-
-fail_image:
-   wsi_destroy_image(&chain->base, &image->base);
-
-   return VK_ERROR_INITIALIZATION_FAILED;
 }
 
 static void
@@ -2221,25 +1967,12 @@ x11_image_finish(struct x11_swapchain *chain,
 {
    xcb_void_cookie_t cookie;
 
-   if (!chain->base.wsi->sw || chain->has_mit_shm) {
+   if (!chain->base.wsi->sw) {
       cookie = xcb_sync_destroy_fence(chain->conn, image->sync_fence);
       xcb_discard_reply(chain->conn, cookie.sequence);
-      xshmfence_unmap_shm(image->shm_fence);
 
       cookie = xcb_free_pixmap(chain->conn, image->pixmap);
       xcb_discard_reply(chain->conn, cookie.sequence);
-
-      cookie = xcb_xfixes_destroy_region(chain->conn, image->update_region);
-      xcb_discard_reply(chain->conn, cookie.sequence);
-
-#ifdef HAVE_DRI3_EXPLICIT_SYNC
-      if (chain->base.image_info.explicit_sync) {
-         for (uint32_t i = 0; i < WSI_ES_COUNT; i++) {
-            cookie = xcb_dri3_free_syncobj(chain->conn, image->dri3_syncobj[i]);
-            xcb_discard_reply(chain->conn, cookie.sequence);
-         }
-      }
-#endif
    }
 
    wsi_destroy_image(&chain->base, &image->base);
@@ -2249,25 +1982,11 @@ x11_image_finish(struct x11_swapchain *chain,
 #endif
 }
 
-static void
-wsi_x11_recompute_dri3_modifier_hash(blake3_hash *hash, const struct wsi_drm_image_params *params)
-{
-   mesa_blake3 ctx;
-   _mesa_blake3_init(&ctx);
-   _mesa_blake3_update(&ctx, &params->num_modifier_lists, sizeof(params->num_modifier_lists));
-   for (uint32_t i = 0; i < params->num_modifier_lists; i++) {
-      _mesa_blake3_update(&ctx, &i, sizeof(i));
-      _mesa_blake3_update(&ctx, params->modifiers[i],
-                          params->num_modifiers[i] * sizeof(*params->modifiers[i]));
-   }
-   _mesa_blake3_update(&ctx, &params->same_gpu, sizeof(params->same_gpu));
-   _mesa_blake3_final(&ctx, *hash);
-}
-
 static void
 wsi_x11_get_dri3_modifiers(struct wsi_x11_connection *wsi_conn,
                            xcb_connection_t *conn, xcb_window_t window,
                            uint8_t depth, uint8_t bpp,
+                           VkCompositeAlphaFlagsKHR vk_alpha,
                            uint64_t **modifiers_in, uint32_t *num_modifiers_in,
                            uint32_t *num_tranches_in,
                            const VkAllocationCallbacks *pAllocator)
@@ -2340,51 +2059,6 @@ out:
    *num_tranches_in = 0;
 }
 
-static bool
-wsi_x11_swapchain_query_dri3_modifiers_changed(struct x11_swapchain *chain)
-{
-   const struct wsi_device *wsi_device = chain->base.wsi;
-
-   if (wsi_device->sw || !wsi_device->supports_modifiers)
-      return false;
-
-   struct wsi_drm_image_params drm_image_params;
-   uint64_t *modifiers[2] = {NULL, NULL};
-   uint32_t num_modifiers[2] = {0, 0};
-
-   struct wsi_x11_connection *wsi_conn =
-         wsi_x11_get_connection((struct wsi_device*)chain->base.wsi, chain->conn);
-
-   xcb_get_geometry_reply_t *geometry =
-         xcb_get_geometry_reply(chain->conn, xcb_get_geometry(chain->conn, chain->window), NULL);
-   if (geometry == NULL)
-      return false;
-   uint32_t bit_depth = geometry->depth;
-   free(geometry);
-
-   drm_image_params = (struct wsi_drm_image_params){
-      .base.image_type = WSI_IMAGE_TYPE_DRM,
-      .same_gpu = wsi_x11_check_dri3_compatible(wsi_device, chain->conn),
-      .explicit_sync = chain->base.image_info.explicit_sync,
-   };
-
-   wsi_x11_get_dri3_modifiers(wsi_conn, chain->conn, chain->window, bit_depth, 32,
-                              modifiers, num_modifiers,
-                              &drm_image_params.num_modifier_lists,
-                              &wsi_device->instance_alloc);
-
-   drm_image_params.num_modifiers = num_modifiers;
-   drm_image_params.modifiers = (const uint64_t **)modifiers;
-
-   blake3_hash hash;
-   wsi_x11_recompute_dri3_modifier_hash(&hash, &drm_image_params);
-
-   for (int i = 0; i < ARRAY_SIZE(modifiers); i++)
-      vk_free(&wsi_device->instance_alloc, modifiers[i]);
-
-   return memcmp(hash, chain->dri3_modifier_hash, sizeof(hash)) != 0;
-}
-
 static VkResult
 x11_swapchain_destroy(struct wsi_swapchain *anv_chain,
                       const VkAllocationCallbacks *pAllocator)
@@ -2392,19 +2066,16 @@ x11_swapchain_destroy(struct wsi_swapchain *anv_chain,
    struct x11_swapchain *chain = (struct x11_swapchain *)anv_chain;
    xcb_void_cookie_t cookie;
 
-   mtx_lock(&chain->thread_state_lock);
-   chain->status = VK_ERROR_OUT_OF_DATE_KHR;
-   u_cnd_monotonic_broadcast(&chain->thread_state_cond);
-   mtx_unlock(&chain->thread_state_lock);
-
-   /* Push a UINT32_MAX to wake up the manager */
-   wsi_queue_push(&chain->present_queue, UINT32_MAX);
-   thrd_join(chain->queue_manager, NULL);
-   thrd_join(chain->event_manager, NULL);
+   if (chain->has_present_queue) {
+      chain->status = VK_ERROR_OUT_OF_DATE_KHR;
+      /* Push a UINT32_MAX to wake up the manager */
+      wsi_queue_push(&chain->present_queue, UINT32_MAX);
+      pthread_join(chain->queue_manager, NULL);
 
-   if (!chain->base.image_info.explicit_sync)
-      wsi_queue_destroy(&chain->acquire_queue);
-   wsi_queue_destroy(&chain->present_queue);
+      if (chain->has_acquire_queue)
+         wsi_queue_destroy(&chain->acquire_queue);
+      wsi_queue_destroy(&chain->present_queue);
+   }
 
    for (uint32_t i = 0; i < chain->base.image_count; i++)
       x11_image_finish(chain, pAllocator, &chain->images[i]);
@@ -2415,10 +2086,9 @@ x11_swapchain_destroy(struct wsi_swapchain *anv_chain,
                                              XCB_PRESENT_EVENT_MASK_NO_EVENT);
    xcb_discard_reply(chain->conn, cookie.sequence);
 
-   mtx_destroy(&chain->present_progress_mutex);
-   u_cnd_monotonic_destroy(&chain->present_progress_cond);
-   mtx_destroy(&chain->thread_state_lock);
-   u_cnd_monotonic_destroy(&chain->thread_state_cond);
+   pthread_mutex_destroy(&chain->present_poll_mutex);
+   pthread_mutex_destroy(&chain->present_progress_mutex);
+   pthread_cond_destroy(&chain->present_progress_cond);
 
    wsi_swapchain_finish(&chain->base);
 
@@ -2427,37 +2097,10 @@ x11_swapchain_destroy(struct wsi_swapchain *anv_chain,
    return VK_SUCCESS;
 }
 
-static void
-wsi_x11_set_adaptive_sync_property(xcb_connection_t *conn,
-                                   xcb_drawable_t drawable,
-                                   uint32_t state)
-{
-   static char const name[] = "_VARIABLE_REFRESH";
-   xcb_intern_atom_cookie_t cookie;
-   xcb_intern_atom_reply_t* reply;
-   xcb_void_cookie_t check;
-
-   cookie = xcb_intern_atom(conn, 0, strlen(name), name);
-   reply = xcb_intern_atom_reply(conn, cookie, NULL);
-   if (reply == NULL)
-      return;
-
-   if (state)
-      check = xcb_change_property_checked(conn, XCB_PROP_MODE_REPLACE,
-                                          drawable, reply->atom,
-                                          XCB_ATOM_CARDINAL, 32, 1, &state);
-   else
-      check = xcb_delete_property_checked(conn, drawable, reply->atom);
-
-   xcb_discard_reply(conn, check.sequence);
-   free(reply);
-}
-
-static VkResult x11_wait_for_present(struct wsi_swapchain *wsi_chain,
-                                     uint64_t waitValue,
-                                     uint64_t timeout)
+static VkResult x11_wait_for_present_queued(
+      struct x11_swapchain *chain,
+      uint64_t waitValue, uint64_t timeout)
 {
-   struct x11_swapchain *chain = (struct x11_swapchain *)wsi_chain;
    struct timespec abs_timespec;
    uint64_t abs_timeout = 0;
    if (timeout != 0)
@@ -2466,17 +2109,17 @@ static VkResult x11_wait_for_present(struct wsi_swapchain *wsi_chain,
    /* Need to observe that the swapchain semaphore has been unsignalled,
     * as this is guaranteed when a present is complete. */
    VkResult result = wsi_swapchain_wait_for_present_semaphore(
-         &chain->base, waitValue, timeout);
+      &chain->base, waitValue, timeout);
    if (result != VK_SUCCESS)
       return result;
 
    timespec_from_nsec(&abs_timespec, abs_timeout);
 
-   mtx_lock(&chain->present_progress_mutex);
+   pthread_mutex_lock(&chain->present_progress_mutex);
    while (chain->present_id < waitValue) {
-      int ret = u_cnd_monotonic_timedwait(&chain->present_progress_cond,
-                                          &chain->present_progress_mutex,
-                                          &abs_timespec);
+      int ret = pthread_cond_timedwait(&chain->present_progress_cond,
+                                       &chain->present_progress_mutex,
+                                       &abs_timespec);
       if (ret == ETIMEDOUT) {
          result = VK_TIMEOUT;
          break;
@@ -2488,7 +2131,134 @@ static VkResult x11_wait_for_present(struct wsi_swapchain *wsi_chain,
    }
    if (result == VK_SUCCESS && chain->present_progress_error)
       result = chain->present_progress_error;
-   mtx_unlock(&chain->present_progress_mutex);
+   pthread_mutex_unlock(&chain->present_progress_mutex);
+   return result;
+}
+
+static VkResult x11_wait_for_present_polled(
+      struct x11_swapchain *chain,
+      uint64_t waitValue, uint64_t timeout)
+{
+   struct timespec rel_timeout, abs_timespec_realtime, start_time;
+   struct timespec abs_timespec_monotonic;
+   uint64_t abs_timeout_monotonic = 0;
+
+   if (timeout != 0)
+      abs_timeout_monotonic = os_time_get_absolute_timeout(timeout);
+
+   /* Mutex abs_timeout is in REALTIME timebase. */
+   timespec_from_nsec(&rel_timeout, timeout);
+   clock_gettime(CLOCK_REALTIME, &start_time);
+   timespec_add(&abs_timespec_realtime, &rel_timeout, &start_time);
+
+   /* Need to observe that the swapchain semaphore has been unsignalled,
+    * as this is guaranteed when a present is complete. */
+   VkResult result = wsi_swapchain_wait_for_present_semaphore(
+      &chain->base, waitValue, timeout);
+   if (result != VK_SUCCESS)
+      return result;
+
+   /* If we have satisfied the present ID right away, just return early. */
+   pthread_mutex_lock(&chain->present_progress_mutex);
+   if (chain->present_id >= waitValue) {
+      result = chain->present_progress_error;
+   } else {
+      result = VK_TIMEOUT;
+   }
+
+   if (result != VK_TIMEOUT) {
+      pthread_mutex_unlock(&chain->present_progress_mutex);
+      return result;
+   }
+
+   timespec_from_nsec(&abs_timespec_monotonic, abs_timeout_monotonic);
+
+   while (chain->present_id_pending < waitValue) {
+      int ret = pthread_cond_timedwait(&chain->present_progress_cond,
+                                       &chain->present_progress_mutex,
+                                       &abs_timespec_monotonic);
+      if (chain->present_progress_error || ret == ETIMEDOUT || ret) {
+         pthread_mutex_unlock(&chain->present_progress_mutex);
+
+         if (chain->present_progress_error)
+            return chain->present_progress_error;
+         else if (ret == ETIMEDOUT)
+            return VK_TIMEOUT;
+         else
+            return VK_ERROR_DEVICE_LOST;
+      }
+   }
+   pthread_mutex_unlock(&chain->present_progress_mutex);
+
+   /* This scheme of taking the message queue lock is not optimal,
+    * but it is only problematic in meaningless situations.
+    * - This path can only be hit by IMMEDIATE or MAILBOX mode.
+    *   Using present wait for IMMEDIATE and MAILBOX is not particularly useful except
+    *   for safe teardown purposes and recycling semaphores.
+    * - There is contention with multiple threads waiting for PresentWait,
+    *   where the first thread to wait is blocking with no timeout and hogs the message queue until
+    *   that present is processed. */
+   int ret;
+   if (timeout == UINT64_MAX)
+      ret = pthread_mutex_lock(&chain->present_poll_mutex);
+   else
+      ret = pthread_mutex_timedlock(&chain->present_poll_mutex, &abs_timespec_realtime);
+
+   if (ret) {
+      if (ret == ETIMEDOUT)
+         return VK_TIMEOUT;
+      else
+         return VK_ERROR_DEVICE_LOST;
+   }
+
+   result = chain->present_progress_error;
+
+   while (result == VK_SUCCESS && chain->present_id < waitValue) {
+      xcb_generic_event_t *event;
+      xcb_flush(chain->conn);
+
+      if (timeout == UINT64_MAX) {
+         /* See comments in x11_manage_fifo_queues about problem scenarios with this call. */
+         event = xcb_wait_for_special_event(chain->conn, chain->special_event);
+         if (!event) {
+            result = x11_swapchain_result(chain, VK_ERROR_SURFACE_LOST_KHR);
+            goto fail;
+         }
+      } else {
+         result = x11_poll_for_special_event(chain, abs_timeout_monotonic, &event);
+         if (result != VK_SUCCESS)
+            goto fail;
+      }
+
+      result = x11_handle_dri3_present_event(chain, (void *)event);
+      /* Ensure that VK_SUBOPTIMAL_KHR is reported to the application */
+      result = x11_swapchain_result(chain, result);
+      free(event);
+   }
+
+fail:
+   pthread_mutex_unlock(&chain->present_poll_mutex);
+   return result;
+}
+
+static VkResult x11_wait_for_present(struct wsi_swapchain *wsi_chain,
+                                     uint64_t waitValue,
+                                     uint64_t timeout)
+{
+   struct x11_swapchain *chain = (struct x11_swapchain *)wsi_chain;
+   VkResult result;
+
+   if (chain->has_present_queue && chain->has_acquire_queue) {
+      /* In this style we have guaranteed forward progress in the present queue thread,
+       * so we don't need to do anything.
+       * This path is hit for FIFO presentation modes. */
+      result = x11_wait_for_present_queued(chain, waitValue, timeout);
+   } else {
+      /* In this style we don't necessarily have forward progress, so we need to pump the message queue ourselves.
+       * This blocks the message queue for other threads that want to present.
+       * In practice, we'll only end up blocking on swapchain teardown, so this isn't a big deal. */
+      result = x11_wait_for_present_polled(chain, waitValue, timeout);
+   }
    return result;
 }
 
@@ -2497,11 +2267,10 @@ x11_get_min_image_count_for_present_mode(struct wsi_device *wsi_device,
                                          struct wsi_x11_connection *wsi_conn,
                                          VkPresentModeKHR present_mode)
 {
-   uint32_t min_image_count = x11_get_min_image_count(wsi_device, wsi_conn->is_xwayland);
-   if (x11_requires_mailbox_image_count(wsi_device, wsi_conn, present_mode))
-      return MAX2(min_image_count, X11_SWAPCHAIN_MAILBOX_IMAGES);
+   if (x11_needs_wait_for_fences(wsi_device, wsi_conn, present_mode))
+      return 5;
    else
-      return min_image_count;
+      return x11_get_min_image_count(wsi_device);
 }
 
 /**
@@ -2534,21 +2303,6 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    if (!wsi_conn)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-   /* Get number of images in our swapchain. This count depends on:
-    * - requested minimal image count
-    * - device characteristics
-    * - presentation mode.
-    */
-   unsigned num_images = pCreateInfo->minImageCount;
-   if (!wsi_device->x11.strict_imageCount) {
-      if (x11_requires_mailbox_image_count(wsi_device, wsi_conn, present_mode) ||
-          wsi_device->x11.ensure_minImageCount) {
-         unsigned present_mode_images = x11_get_min_image_count_for_present_mode(
-               wsi_device, wsi_conn, pCreateInfo->presentMode);
-         num_images = MAX2(num_images, present_mode_images);
-      }
-   }
-
    /* Check that we have a window up-front. It is an error to not have one. */
    xcb_window_t window = x11_surface_get_window(icd_surface);
 
@@ -2565,52 +2319,33 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    free(geometry);
 
    /* Allocate the actual swapchain. The size depends on image count. */
-   size_t size = sizeof(*chain) + num_images * sizeof(chain->images[0]);
+   size_t size = sizeof(*chain) + pCreateInfo->minImageCount * sizeof(chain->images[0]);
    chain = vk_zalloc(pAllocator, size, 8,
                       VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
    if (chain == NULL)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-   int ret = mtx_init(&chain->present_progress_mutex, mtx_plain);
-   if (ret != thrd_success) {
+   int ret = pthread_mutex_init(&chain->present_progress_mutex, NULL);
+   if (ret != 0) {
       vk_free(pAllocator, chain);
       return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
 
-   ret = mtx_init(&chain->thread_state_lock, mtx_plain);
-   if (ret != thrd_success) {
-      mtx_destroy(&chain->present_progress_mutex);
+   ret = pthread_mutex_init(&chain->present_poll_mutex, NULL);
+   if (ret != 0) {
+      pthread_mutex_destroy(&chain->present_progress_mutex);
       vk_free(pAllocator, chain);
       return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
-
-   ret = u_cnd_monotonic_init(&chain->thread_state_cond);
-   if (ret != thrd_success) {
-      mtx_destroy(&chain->present_progress_mutex);
-      mtx_destroy(&chain->thread_state_lock);
-      vk_free(pAllocator, chain);
-      return VK_ERROR_OUT_OF_HOST_MEMORY;
-   }
-
-   ret = u_cnd_monotonic_init(&chain->present_progress_cond);
-   if (ret != thrd_success) {
-      mtx_destroy(&chain->present_progress_mutex);
-      mtx_destroy(&chain->thread_state_lock);
-      u_cnd_monotonic_destroy(&chain->thread_state_cond);
+   /*
+   bool bret = wsi_init_pthread_cond_monotonic(&chain->present_progress_cond);
+   if (!bret) {
+      pthread_mutex_destroy(&chain->present_progress_mutex);
+      pthread_mutex_destroy(&chain->present_poll_mutex);
       vk_free(pAllocator, chain);
       return VK_ERROR_OUT_OF_HOST_MEMORY;
    }
-
-   uint32_t present_caps = 0;
-   xcb_present_query_capabilities_cookie_t present_query_cookie;
-   xcb_present_query_capabilities_reply_t *present_query_reply;
-   present_query_cookie = xcb_present_query_capabilities(conn, window);
-   present_query_reply = xcb_present_query_capabilities_reply(conn, present_query_cookie, NULL);
-   if (present_query_reply) {
-      present_caps = present_query_reply->capabilities;
-      free(present_query_reply);
-   }
-
+   */
    struct wsi_base_image_params *image_params = NULL;
    struct wsi_cpu_image_params cpu_image_params;
    struct wsi_drm_image_params drm_image_params;
@@ -2618,32 +2353,22 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    uint32_t num_modifiers[2] = {0, 0};
    if (wsi_device->sw) {
       cpu_image_params = (struct wsi_cpu_image_params) {
-         .base.image_type = WSI_IMAGE_TYPE_CPU,
-         .alloc_shm = wsi_conn->has_mit_shm ? &alloc_shm : NULL,
+         .base.image_type = WSI_IMAGE_TYPE_CPU
       };
       image_params = &cpu_image_params.base;
    } else {
       drm_image_params = (struct wsi_drm_image_params) {
          .base.image_type = WSI_IMAGE_TYPE_DRM,
          .same_gpu = wsi_x11_check_dri3_compatible(wsi_device, conn),
-         .explicit_sync =
-#ifdef HAVE_DRI3_EXPLICIT_SYNC
-            wsi_conn->has_dri3_explicit_sync &&
-            (present_caps & XCB_PRESENT_CAPABILITY_SYNCOBJ) &&
-            wsi_device_supports_explicit_sync(wsi_device),
-#else
-            false,
-#endif
       };
       if (wsi_device->supports_modifiers) {
          wsi_x11_get_dri3_modifiers(wsi_conn, conn, window, bit_depth, 32,
+                                    pCreateInfo->compositeAlpha,
                                     modifiers, num_modifiers,
                                     &drm_image_params.num_modifier_lists,
                                     pAllocator);
          drm_image_params.num_modifiers = num_modifiers;
          drm_image_params.modifiers = (const uint64_t **)modifiers;
-
-         wsi_x11_recompute_dri3_modifier_hash(&chain->dri3_modifier_hash, &drm_image_params);
       }
       image_params = &drm_image_params.base;
    }
@@ -2661,11 +2386,13 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->base.get_wsi_image = x11_get_wsi_image;
    chain->base.acquire_next_image = x11_acquire_next_image;
    chain->base.queue_present = x11_queue_present;
-   chain->base.wait_for_present = x11_wait_for_present;
+   
+   if (!wsi_device->sw)
+      chain->base.wait_for_present = x11_wait_for_present;
+
    chain->base.release_images = x11_release_images;
-   chain->base.set_present_mode = x11_set_present_mode;
    chain->base.present_mode = present_mode;
-   chain->base.image_count = num_images;
+   chain->base.image_count = pCreateInfo->minImageCount;
    chain->conn = conn;
    chain->window = window;
    chain->depth = bit_depth;
@@ -2673,19 +2400,18 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->send_sbc = 0;
    chain->sent_image_count = 0;
    chain->last_present_msc = 0;
+   chain->has_acquire_queue = false;
+   chain->has_present_queue = false;
    chain->status = VK_SUCCESS;
    chain->has_dri3_modifiers = wsi_conn->has_dri3_modifiers;
    chain->has_mit_shm = wsi_conn->has_mit_shm;
-   chain->has_async_may_tear = present_caps & XCB_PRESENT_CAPABILITY_ASYNC_MAY_TEAR;
 
    /* When images in the swapchain don't fit the window, X can still present them, but it won't
     * happen by flip, only by copy. So this is a suboptimal copy, because if the client would change
     * the chain extents X may be able to flip
     */
-   if (!wsi_device->x11.ignore_suboptimal) {
-      if (chain->extent.width != cur_width || chain->extent.height != cur_height)
-         chain->status = VK_SUBOPTIMAL_KHR;
-   }
+   if (chain->extent.width != cur_width || chain->extent.height != cur_height)
+       chain->status = VK_SUBOPTIMAL_KHR;
 
    /* On a new swapchain this helper variable is set to false. Once we present it will have an
     * impact once we ever do at least one flip and go back to copying afterwards. It is presumed
@@ -2706,26 +2432,27 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
     */
    chain->copy_is_suboptimal = false;
 
-   /* For our swapchain we need to listen to following Present extension events:
-    * - Configure: Window dimensions changed. Images in the swapchain might need
-    *              to be reallocated.
-    * - Complete: An image from our swapchain was presented on the output.
-    * - Idle: An image from our swapchain is not anymore accessed by the X
-    *         server and can be reused.
-    */
-   chain->event_id = xcb_generate_id(chain->conn);
-   uint32_t event_mask = XCB_PRESENT_EVENT_MASK_CONFIGURE_NOTIFY |
-                         XCB_PRESENT_EVENT_MASK_COMPLETE_NOTIFY;
-   if (!chain->base.image_info.explicit_sync)
-      event_mask |= XCB_PRESENT_EVENT_MASK_IDLE_NOTIFY;
-   xcb_present_select_input(chain->conn, chain->event_id, chain->window, event_mask);
-
-   /* Create an XCB event queue to hold present events outside of the usual
-    * application event queue
-    */
-   chain->special_event =
-      xcb_register_for_special_xge(chain->conn, &xcb_present_id,
-                                   chain->event_id, NULL);
+   if (!wsi_device->sw) {
+      /* For our swapchain we need to listen to following Present extension events:
+       * - Configure: Window dimensions changed. Images in the swapchain might need
+       *              to be reallocated.
+       * - Complete: An image from our swapchain was presented on the output.
+       * - Idle: An image from our swapchain is not anymore accessed by the X
+       *         server and can be reused.
+       */
+      chain->event_id = xcb_generate_id(chain->conn);
+      xcb_present_select_input(chain->conn, chain->event_id, chain->window,
+                               XCB_PRESENT_EVENT_MASK_CONFIGURE_NOTIFY |
+                               XCB_PRESENT_EVENT_MASK_COMPLETE_NOTIFY |
+                               XCB_PRESENT_EVENT_MASK_IDLE_NOTIFY);
+
+      /* Create an XCB event queue to hold present events outside of the usual
+       * application event queue
+       */
+      chain->special_event =
+         xcb_register_for_special_xge(chain->conn, &xcb_present_id,
+                                      chain->event_id, NULL);
+   }
 
    /* Create the graphics context. */
    chain->gc = xcb_generate_id(chain->conn);
@@ -2750,56 +2477,64 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
          goto fail_init_images;
    }
 
-   /* The queues have a length of base.image_count + 1 because we will
-    * occasionally use UINT32_MAX to signal the other thread that an error
-    * has occurred and we don't want an overflow.
+   /* Initialize queues for images in our swapchain. Possible queues are:
+    * - Present queue: for images sent to the X server but not yet presented.
+    * - Acquire queue: for images already presented but not yet released by the
+    *                  X server.
+    *
+    * In general queues are not used on software drivers, otherwise which queues
+    * are used depends on our presentation mode:
+    * - Fifo: present and acquire
+    * - Mailbox: present only
+    * - Immediate: present when we wait on fences before buffer submission
     */
-   ret = wsi_queue_init(&chain->present_queue, chain->base.image_count + 1);
-   if (ret) {
-      goto fail_init_images;
-   }
-
-   /* Acquire queue is only needed when using implicit sync */
-   if (!chain->base.image_info.explicit_sync) {
-      ret = wsi_queue_init(&chain->acquire_queue, chain->base.image_count + 1);
+   if ((chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR ||
+        chain->base.present_mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR ||
+        x11_needs_wait_for_fences(wsi_device, wsi_conn,
+                                  chain->base.present_mode)) &&
+       !wsi_device->sw) {
+      chain->has_present_queue = true;
+
+      /* The queues have a length of base.image_count + 1 because we will
+       * occasionally use UINT32_MAX to signal the other thread that an error
+       * has occurred and we don't want an overflow.
+       */
+      int ret;
+      ret = wsi_queue_init(&chain->present_queue, chain->base.image_count + 1);
       if (ret) {
-         wsi_queue_destroy(&chain->present_queue);
          goto fail_init_images;
       }
 
-      for (unsigned i = 0; i < chain->base.image_count; i++)
-         wsi_queue_push(&chain->acquire_queue, i);
-   }
+      if (chain->base.present_mode == VK_PRESENT_MODE_FIFO_KHR ||
+          chain->base.present_mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR) {
+         chain->has_acquire_queue = true;
 
-   ret = thrd_create(&chain->queue_manager,
-                     x11_manage_present_queue, chain);
-   if (ret != thrd_success)
-      goto fail_init_fifo_queue;
+         ret = wsi_queue_init(&chain->acquire_queue, chain->base.image_count + 1);
+         if (ret) {
+            wsi_queue_destroy(&chain->present_queue);
+            goto fail_init_images;
+         }
 
-   ret = thrd_create(&chain->event_manager,
-                     x11_manage_event_queue, chain);
-   if (ret != thrd_success)
-      goto fail_init_event_queue;
+         for (unsigned i = 0; i < chain->base.image_count; i++)
+            wsi_queue_push(&chain->acquire_queue, i);
+      }
 
-   /* It is safe to set it here as only one swapchain can be associated with
-    * the window, and swapchain creation does the association. At this point
-    * we know the creation is going to succeed. */
-   wsi_x11_set_adaptive_sync_property(conn, window,
-                                      wsi_device->enable_adaptive_sync);
+      ret = pthread_create(&chain->queue_manager, NULL,
+                           x11_manage_fifo_queues, chain);
+      if (ret) {
+         wsi_queue_destroy(&chain->present_queue);
+         if (chain->has_acquire_queue)
+            wsi_queue_destroy(&chain->acquire_queue);
 
-   *swapchain_out = &chain->base;
+         goto fail_init_images;
+      }
+   }
 
-   return VK_SUCCESS;
+   assert(chain->has_present_queue || !chain->has_acquire_queue);
 
-fail_init_event_queue:
-   /* Push a UINT32_MAX to wake up the manager */
-   wsi_queue_push(&chain->present_queue, UINT32_MAX);
-   thrd_join(chain->queue_manager, NULL);
+   *swapchain_out = &chain->base;
 
-fail_init_fifo_queue:
-   wsi_queue_destroy(&chain->present_queue);
-   if (!chain->base.image_info.explicit_sync)
-      wsi_queue_destroy(&chain->acquire_queue);
+   return VK_SUCCESS;
 
 fail_init_images:
    for (uint32_t j = 0; j < image; j++)
@@ -2831,8 +2566,8 @@ wsi_x11_init_wsi(struct wsi_device *wsi_device,
       goto fail;
    }
 
-   int ret = mtx_init(&wsi->mutex, mtx_plain);
-   if (ret != thrd_success) {
+   int ret = pthread_mutex_init(&wsi->mutex, NULL);
+   if (ret != 0) {
       if (ret == ENOMEM) {
          result = VK_ERROR_OUT_OF_HOST_MEMORY;
       } else {
@@ -2855,24 +2590,6 @@ wsi_x11_init_wsi(struct wsi_device *wsi_device,
          wsi_device->x11.override_minImageCount =
             driQueryOptioni(dri_options, "vk_x11_override_min_image_count");
       }
-      if (driCheckOption(dri_options, "vk_x11_strict_image_count", DRI_BOOL)) {
-         wsi_device->x11.strict_imageCount =
-            driQueryOptionb(dri_options, "vk_x11_strict_image_count");
-      }
-      if (driCheckOption(dri_options, "vk_x11_ensure_min_image_count", DRI_BOOL)) {
-         wsi_device->x11.ensure_minImageCount =
-            driQueryOptionb(dri_options, "vk_x11_ensure_min_image_count");
-      }
-      wsi_device->x11.xwaylandWaitReady = true;
-      if (driCheckOption(dri_options, "vk_xwayland_wait_ready", DRI_BOOL)) {
-         wsi_device->x11.xwaylandWaitReady =
-            driQueryOptionb(dri_options, "vk_xwayland_wait_ready");
-      }
-
-      if (driCheckOption(dri_options, "vk_x11_ignore_suboptimal", DRI_BOOL)) {
-         wsi_device->x11.ignore_suboptimal =
-            driQueryOptionb(dri_options, "vk_x11_ignore_suboptimal");
-      }
    }
 
    wsi->base.get_support = x11_surface_get_support;
@@ -2889,7 +2606,7 @@ wsi_x11_init_wsi(struct wsi_device *wsi_device,
    return VK_SUCCESS;
 
 fail_mutex:
-   mtx_destroy(&wsi->mutex);
+   pthread_mutex_destroy(&wsi->mutex);
 fail_alloc:
    vk_free(alloc, wsi);
 fail:
@@ -2912,7 +2629,7 @@ wsi_x11_finish_wsi(struct wsi_device *wsi_device,
 
       _mesa_hash_table_destroy(wsi->connections, NULL);
 
-      mtx_destroy(&wsi->mutex);
+      pthread_mutex_destroy(&wsi->mutex);
 
       vk_free(alloc, wsi);
    }
-- 
GitLab

